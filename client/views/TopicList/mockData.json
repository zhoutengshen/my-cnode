{
    "success": true,
    "data": [
        {
            "id": "5b9b5d2ba5ed9d2159fa312e",
            "author_id": "504c28a2e2b845157708cb61",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>cnode一直是使用七牛的对象存储和cdn加速服务，之前在七牛开启对象存储bucket是配域名的，现在由于审核或者安全方面的原因，七牛把那些配赠的域名都定义成了『测试域名』，给定了下线时间。所以cnode需要改造成自定义域名的方式来访问七牛的对象存储资源。</p>\n<p>之前的社区通过 <code>dn-cnode.qbox.me</code> 访问用户上传资源，用 <code>o4j806krb.qnssl.com</code> 来访问网站的js和css等文件。</p>\n<p>目前前者改成 <code>static.cnodejs.org</code>，后者改成 <code>static2.cnodejs.org</code>。</p>\n<p>改造范围包括：</p>\n<ol>\n<li>所有帖子和回复中的图片地址</li>\n<li>社区自有图片和js和css等资源地址</li>\n</ol>\n<p>有问题请及时反馈哈，发邮件给我就好</p>\n</div>",
            "title": "cnode社区静态资源域名改造",
            "last_reply_at": "2018-10-19T10:27:36.892Z",
            "good": false,
            "top": true,
            "reply_count": 42,
            "visit_count": 6136,
            "create_at": "2018-09-14T07:03:07.865Z",
            "author": {
                "loginname": "alsotang",
                "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
            }
        },
        {
            "id": "5baee8de9545eaf107b9c6f3",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>Node.js 新生态</h1>\n<p>关于 SSR、IoT、应用治理，以及来自腾讯的新物种 —— Tars.js，</p>\n<p>腾讯、ThoughtWorks、阿里巴巴的 4 位分享者，期待和你交流碰撞层出不穷的 Node.js 新应用场景。</p>\n<h2>Agenda</h2>\n<p><img src=\"//static.cnodejs.org/FmVpEKuYsrXt8ek9z8d6DjFexMAc\" alt=\"20180929110352.png\"></p>\n<p>时间：2018.10.13\n地点：深圳后海阿里中心\n报名链接: <a href=\"https://survey.alibaba.com/survey/AgD9rVfQT\">https://survey.alibaba.com/survey/AgD9rVfQT</a>\n活动主页: <a href=\"http://nodejs.club/\">http://nodejs.club/</a></p>\n<p>注意: 沙龙场地有限，在报名链接中仔细填写「关注Node.js 新生态中的哪些具体问题」对最终挑选参加资格会有帮助。</p>\n</div>",
            "title": "Node 地下铁第七期「深圳站」线下沙龙邀约 - Node.js 新生态",
            "last_reply_at": "2018-10-19T01:53:40.382Z",
            "good": false,
            "top": true,
            "reply_count": 22,
            "visit_count": 2927,
            "create_at": "2018-09-29T02:52:14.701Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
            }
        },
        {
            "id": "5ba5fd6237a6965f59051bd1",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p>『大吉大利，明早吃蛋。』</p>\n<p>底部有文化衫活动邀您参加。</p>\n</blockquote>\n<p>知乎原文地址：<a href=\"https://zhuanlan.zhihu.com/p/45143762\">https://zhuanlan.zhihu.com/p/45143762</a></p>\n<p><img src=\"//static.cnodejs.org/FkV4SW_6zuURqOdHc0lalW7pC7Fv\" alt=\"image.png\"></p>\n<p>2016 年 9 月，我们在 JSConf China 2016 上宣布了 Egg 开源，至今整整 2 年了。\n在 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">Egg 2.0 发布通告</a> 提到，核心代码已经很稳定，<strong>后续重心主要在开发者体验方面的优化。</strong></p>\n<blockquote>\n<p>Egg 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。</p>\n<p>既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。</p>\n<p>它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<p>接下来跟大家分享下，过去 9 个月里面，我们的一些产出和数据，本文较长，请慢慢品用：</p>\n<ul>\n<li><strong>开发者数据分享</strong></li>\n<li><strong>文化衫活动邀请</strong></li>\n<li><strong>开发者体验优化</strong>\n<ul>\n<li>TypeScript 的支持</li>\n<li>新增「生命周期」</li>\n<li>Alinode 接入指南</li>\n<li>和 Java 的互联互通方案</li>\n<li>实践案例 - 用 Egg 重构的 cnode 社区</li>\n<li>来自语雀团队的 sequelize ORM 实践分享</li>\n<li>与 Webpack 等前端工程的实践分享</li>\n<li>错误处理和 opentracing 的 RFC</li>\n<li>egg-init 骨架重构方案</li>\n</ul>\n</li>\n<li><strong>未来规划</strong></li>\n</ul>\n<hr>\n<h2>开发者数据</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/84182/1537602757084-21ffa6c7-d95d-4da0-b48b-6312551d1b03.png\" alt=\"image.png | left | 600x303\"></p>\n<ul>\n<li>官网 PV 在 1.2w 左右。</li>\n<li>npm egg 模块数 1006 个，GitHub 依赖库 3738 个。</li>\n<li>一千多个 Pull Request，2200 个 Issue，130 多位 Contributors 。</li>\n<li>共发布了 81 个版本，<a href=\"https://github.com/eggjs/egg/releases\">Release Note</a> 。</li>\n<li>社区实践项目：<a href=\"https://github.com/cnodejs/egg-cnode\">cnodejs/egg-cnode</a> ，<a href=\"https://github.com/eggjs/awesome-egg\">eggjs/awesome-egg</a> 。</li>\n<li><a href=\"https://zhuanlan.zhihu.com/eggjs\">知乎专栏 Node.js</a> 一共发布了 48 篇文章，7600 订阅，阅读数据未知（知乎创作者中心看不上咱，不给内测资格 😭）。</li>\n</ul>\n<p><strong>正在使用 Egg 的公司，不完全统计：</strong></p>\n<ul>\n<li>深度使用的： 阿里巴巴，全民直播，网易考拉</li>\n<li>使用并有分享过使用经验的：去哪儿，摩拜，点评</li>\n<li>有个别团队咨询过试水但最终有没有落地的不知道：美团，新浪，百度，腾讯，YY 等</li>\n</ul>\n<p><strong>顺便分享一个 cnpm 的</strong><a href=\"https://fengmk2.com/npm-china-mirror-downloads?year=2018\">统计数据</a><strong>：</strong></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/84182/1537602856784-1517e844-15e1-495f-b58b-c5103a09b5a3.png\" alt=\"image.png | left | 720x423\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/84182/1537602864083-a887fcab-8754-4ba6-90cb-eada7a3a477f.png\" alt=\"image.png | left | 720x413\"></p>\n<hr>\n<h2>文化衫活动</h2>\n<p>欢迎大家访问以下链接，分享你们的实践经验，有机会获得 Egg 文化衫和相关周边喔~\n另外，第 10000 Star 的同学 <a href=\"https://github.com/zhyjor\">godmeir</a> 请联系我们。</p>\n<p><a href=\"https://www.zhihu.com/question/273783655\">『2018 年 EggJS 怎么样了？对它的看法有什么变化？』</a></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/84182/1537602940849-da573bac-6899-47c1-ae18-e288e6d6fe79.png\" alt=\"image.png | left | 600x800\"></p>\n<hr>\n<h2>开发者体验优化</h2>\n<p>接下来跟大家分享下这段时间来，我们在『开发者体验』方面做的一些优化。</p>\n<h3>TypeScript</h3>\n<p>这几年来 TypeScript 很受欢迎，它的静态类型检查，智能提示，IDE 友好性等特性，对于大规模企业级应用，是非常的有价值的，被视为是企业级 JS 开发的未来之一。</p>\n<p>阿里内部实践 TS 也蛮久了，在 5 个月前，也把我们的其中一部分成熟的实践，分享出来：\n<a href=\"https://zhuanlan.zhihu.com/p/35334932\">『天猪：当 Egg 遇到 TypeScript，收获茶叶蛋一枚』</a></p>\n<p>非常感谢 @吖猩 在这领域的持续贡献：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/43181384\">ts-node 下错误堆栈问题排查小记</a></li>\n<li><a href=\"https://github.com/whxaxes/blog/issues/12\">Egg TS 改造总结</a></li>\n<li><a href=\"https://github.com/whxaxes/blog/issues/11\">Typescript 在 Egg + Vue 应用中的实践</a></li>\n</ul>\n<p>这块目前还在持续优化中，有兴趣的同学可以参与以下几项优化：</p>\n<ul>\n<li>egg-ts-helper 增加对 js 的支持，这样非 ts 的同学，也能享受到智能提示和静态检查的 Buffer 加成。</li>\n<li>完善插件自带的 d.ts 方便其他开发者。</li>\n<li>分享你的上层封装，如通过装饰器来注册路由或 AOP。（内部有不少实践，但还未达成共识）</li>\n</ul>\n<blockquote>\n<p>PS： Egg.js 本身不会使用 TypeScript 重写，对于框架本身而言，JS 的灵活性可以让它更容易实现一些特性，同时它也并没有那么复杂的业务逻辑，TypeScript 并无法给框架研发带来更多的帮助。</p>\n</blockquote>\n<h3>生命周期</h3>\n<p>之前 Egg 提供给开发者在启动期的钩子不多，只有 beforeStart 几个。\n感谢 killagu 同学给我们补充了更细致的生命周期，相关的 RFC 和文档如下：</p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg/issues/2520#issuecomment-399008659\">[RFC] egg-core 增加应用启动阶段 · Issue #2520 </a></li>\n<li><a href=\"https://eggjs.app/zh-cn/advanced/loader.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">Egg 文档 - 生命周期</a>  （目前文档还有较大的优化空间，我们将在后续继续完善。）</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; app.js\nclass AppBootHook {\n  configDidLoad() {\n    &#x2F;&#x2F; Config, Plugin files have did load.\n  }\n\n  async didLoad() {\n    &#x2F;&#x2F; All files have did load, start plugin here.\n  }\n\n  async willReady() {\n    &#x2F;&#x2F; All plugins have started, can do some thing before app ready.\n  }\n\n  async didReady() {\n    &#x2F;&#x2F; Worker is ready, can do some things don&#x27;t need to block the app boot.\n  }\n\n  async serverDidReady() {\n    &#x2F;&#x2F; Server is listening.\n  }\n\n  async beforeClose() {\n    &#x2F;&#x2F; Do some thing before app close.\n  }\n}\n</code></pre><h3>Alinode</h3>\n<p>Node 发展到今天，已经被越来越广泛地应用到前后端分离、全栈开发、客户端工具等领域。\n然而，相对于应用层的蓬勃发展，其 Runtime 对于绝大部分前端出身的开发者来说，处于黑盒的状态，这一点并没有得到很好的改善，从而也阻碍了 Node.js 在业务中的应用和推广。</p>\n<p>作为一个 Node 开发者，最头痛的事莫过于莫名其妙的 CPU 100% 和内存泄露导致的 OOM。</p>\n<p>所幸的是，阿里云 @朴灵 团队的 <a href=\"https://www.aliyun.com/product/nodejs\">Node.js 性能平台</a> 为 Node 开发者提供了：<code>性能监控、安全提醒、故障排查、性能优化</code> 等服务的整体性解决方案，提供完善的工具链和服务，协助开发者快速发现和定位线上问题。这些年来，为我们解决了非常多的线上问题，为业务保驾护航。</p>\n<p>相关分享：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/41178823\">Node 案发现场揭秘 —— Coredump 还原线上异常</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34702356\">一行 delete require.cache 引发的内存泄漏血案</a></li>\n<li><a href=\"https://eggjs.app/zh-cn/core/deployment.html#nodejs-%E6%80%A7%E8%83%BD%E5%B9%B3%E5%8F%B0alinode\">Egg 文档 - Alinode 一键接入</a></li>\n</ul>\n<p>当然，在日常的答疑中，很多同学也表达了对数据安全方面的担忧。从我个人的角度来看，Alinode 的采集脚本，都是开源了，不会采集隐私数据。实在不行，在压测期接入用用也行，绝对可以让我们少掉一点头发，良心推荐。</p>\n<h3>和 Java 互联互通的方案</h3>\n<p>Node.js 在蚂蚁和阿里已经发展了四、五年时间，从最开始「前端工程师的玩具」，到 Web、BFF 场景的破局，逐步走到线上甚至是一些核心业务，非常不容易。</p>\n<p>回头想想 Nodejs 为什么能活下来？依靠的绝不仅仅是：非阻塞I/O、事件驱动、轻量这些官方宣传的特性，<strong>我们认为更重要一点是我们打通了和 Java 的桥梁，实现了互联互通，这才让它真正融入阿里的技术体系。</strong></p>\n<p>伴随 <a href=\"https://www.cloud.alipay.com/products/SOFA\">蚂蚁 SOFA Java 技术栈</a> 的开源，我们也开源了 Nodejs RPC 相关模块，希望能填补 Nodejs 社区这块的空白，也将我们几年来在 Nodejs 基础技术的一些经验做个总结和分享。</p>\n<p>推荐阅读小丸子姐姐的相关科普文章：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/38004479\">Eggjs 和 SOFA 的跨语言互调</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/38012481\">聊聊 Node.js RPC（一）— 协议</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40606909\">聊聊 Node.js RPC（二）— 服务发现</a></li>\n</ul>\n<h3>egg-cnode</h3>\n<p>朴老师发起的 <a href=\"https://github.com/cnodejs/egg-cnode\">cnodejs/egg-cnode</a> 项目，用 Egg 重写了 cnode 社区应用。\n目前完成了功能层面的重构以及测试用例的补全：</p>\n<ul>\n<li>文件数减少 41，减少 22%</li>\n<li>代码行数减少 2460 行，减少 4.7%</li>\n<li>测试代码减少 980 行，减少 39%，覆盖率高于原项目。</li>\n</ul>\n<p>目前还有较大的优化空间，因为第一阶段专注于功能迁移，不做大的优化，有些使用方式不符合 Egg 的最佳实践，欢迎有兴趣的同学加入一起完善。</p>\n<h3>值得关注的 RFC 和分享</h3>\n<blockquote>\n<p>在 eggjs 团队的日常协作中，遵循「基于 GitLab 的硬盘式异步协作模式」。\n通过 <a href=\"https://github.com/eggjs/egg/issues\">issue</a> 发起 RFC 提案 -&gt; 讨论定稿-&gt; 提交 Pull Request -&gt; Code Review -&gt; 发布。\n这样便于沉淀，即使是当时没有参与讨论的开发者，事后也能通过 issue 了解某个功能设计的前因后果。</p>\n</blockquote>\n<p><strong>Θ 来自 <strong><a href=\"https://www.yuque.com/\">语雀团队</a></strong> 的 ORM 实践分享</strong></p>\n<ul>\n<li>语雀是基于 Egg 技术栈研发的，算是为数不多的涉及到各个技术点的 Node 大应用。</li>\n<li><a href=\"https://eggjs.app/zh-cn/tutorials/sequelize.html\">Egg 文档 - Sequelize</a></li>\n</ul>\n<p><strong>Θ 与 Webpack 等前端工程的实践分享</strong></p>\n<ul>\n<li><a href=\"https://eggjs.app/zh-cn/tutorials/assets.html\">Egg 文档 - Assets 静态资源</a></li>\n<li>来自 <a href=\"https://zhuanlan.zhihu.com/easywebpack\">easywebpack</a> 的实践</li>\n<li>上层同构框架：<a href=\"https://github.com/alibaba/beidou\">alibaba/beidou</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/41947819\">Serlina</a></li>\n</ul>\n<p><strong>Θ 错误处理 &amp;&amp; 问题跟踪</strong></p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg/issues/39\">[RFC] egg-opentracing · Issue #39</a></li>\n<li><a href=\"https://github.com/eggjs/egg/issues/1086\">[RFC] 应用自定义 4xx 和 5xx 的方案 · Issue #1086</a></li>\n<li><a href=\"https://github.com/eggjs/egg/issues/1898#issuecomment-386823829\">[RFC] 统计 egg 加载过程的各步骤的耗时 · Issue #1898</a></li>\n<li><a href=\"https://github.com/eggjs/egg/issues/2897\">handle unconsume multipart request data in egg itself. · Issue #2897</a></li>\n</ul>\n<p><strong>Θ 工具优化</strong>\n目前的 egg-init 存在以下问题：</p>\n<ul>\n<li>脚手架逻辑集中化，全部在 egg-init 本身，作为全局命令，更新不方便。</li>\n<li>模板无法定制自己的逻辑，无法代码共享。</li>\n<li>没有 sub generator，如 egg-init add controller Test 这样的功能。</li>\n<li>脚手架只在项目初始化时用到，无法支撑升级功能，容易腐化和分裂。</li>\n<li>上层封装不方便，不支持 preset 。</li>\n</ul>\n<p>因此提出了 『<a href=\"https://github.com/eggjs/egg/issues/2892\">[RFC] egg-init refactor </a>』，应该下个月可以完工并分享给大家。</p>\n<p><strong>Θ 科普文</strong>\n提到 Egg 值得自豪的应该是我们的文档吧，我们深知前端开发者在后端知识面还有很多需要科普的，也很乐意分享我们的实践：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/36240171\">『专访死马：为什么说Egg.js是企业级Node框架』</a></p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/39226941\">科普文：运维不给升级 Node 版本怎么办？</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/p/39209596\">科普文：为什么不能在服务器上 npm install ？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/38012481\">聊聊 Node.js RPC（一）— 协议</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40606909\">聊聊 Node.js RPC（二）— 服务发现</a></li>\n</ul>\n<h2>未来规划</h2>\n<p>老实说没有太多新特性，还是那个原因：<strong>Egg 采用的是『微内核 + 插件 + 上层框架』模式。</strong></p>\n<p>Egg 自身的迭代采取插件化的开发机制，功能分散在不同的模块中，可能开发者在使用时感知不到它的版本变更，但其实它一直都在进化。每周都可能有新特性和 BugFix 发布，更像是一个『改良派』而不是『改革派』，它会在兼容的前提下不断进化。</p>\n<p>接下来的规划，还将继续放在 <strong>『开发者体验优化 + 实践经验分享』</strong> 方面。</p>\n<ul>\n<li>egg cli 工具链和骨架的重构优化。</li>\n<li>TypeScript 的继续优化，以及增加对 js 项目智能提示方面的支持。</li>\n<li>更多的实践项目和科普分享。</li>\n<li>国际化。</li>\n</ul>\n<p>仅凭我们自己的精力是远远不够的，欢迎社区的大家一起加入，共同推动 Node 的发展。</p>\n<h2>写在最后</h2>\n<ul>\n<li>如果你喜欢 Egg，请支持我们：</li>\n<li>分享本文，为我们点赞。</li>\n<li>来分享下你们的实践，无论大小，这很重要，谢谢，将有机会获得我们的文化衫。</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/273783655\">『2018 年 EggJS 怎么样了？对它的看法有什么变化？』</a></p>\n<ul>\n<li>如果喜欢我的文章，请关注 <a href=\"https://www.zhihu.com/question/273783655\">我的知乎</a> 和 <a href=\"https://www.zhihu.com/question/273783655\">Follow GitHub</a> 。</li>\n<li>广州阿里游戏，招前端，熟悉动效，Node 的速来~</li>\n</ul>\n</div>",
            "title": "EggJS 10000 Star + 2 years - 阿里 Node 企业级框架 ✨✨✨",
            "last_reply_at": "2018-10-18T13:53:29.711Z",
            "good": true,
            "top": true,
            "reply_count": 46,
            "visit_count": 6402,
            "create_at": "2018-09-22T08:29:22.948Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars2.githubusercontent.com/u/227713?v=4&s=120"
            }
        },
        {
            "id": "5b911f1837b3005a0b0e6c16",
            "author_id": "55500f555809a4b66f37f625",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>活动说明</h2>\n<h3>本次活动由蚂蚁金服-国际事业群-前端团队承办。</h3>\n<blockquote>\n<ul>\n<li>时间：2018 年 9 月 23 日 14:00 - 18:00</li>\n<li>地点：浙大玉泉校区邵逸夫科学馆 117 会堂</li>\n<li>报名链接：<a href=\"https://www.bagevent.com/event/1843696\">https://www.bagevent.com/event/1843696</a></li>\n</ul>\n</blockquote>\n<hr>\n<h2>活动的主题如下（包括PPT）：</h2>\n<h3>《DataHub2 - 你的最后一个 mock 方案》</h3>\n<p>PPT：<a href=\"https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925050307-1fa501d9-b3fd-44c7-953b-8291d2c86ea8.pdf\" title=\"size:5046844\">download: DataHub.pdf</a></p>\n<p>分享时间：14:00 - 14:40</p>\n<p>主讲人介绍：张宇恒(<a href=\"https://github.com/zhangyuheng\">@zhangyuheng</a>) - 蚂蚁国际高级前端工程师，<a href=\"https://github.com/macacajs/macaca-datahub\">DataHub</a> 核心开发，格言：To Be A Better Hacker 。</p>\n<p><img src=\"//static.cnodejs.org/FuvmcnVJIRbF-xqcrJDFfiag0bSi\" alt=\"1536220954455-08024e18-182c-4e9c-8534-99ca63d0dd4b.png | left\"></p>\n<p>内容：DataHub 是为解决复杂业务场景而诞生，但同时能够渐进式退化，为项目研发提供通用的 mock 解决方案。舒适的 Web 研发体验，从研发、测试、联调阶段贯穿始终的数据提供能力，剖析如何设计一个 mock 平台的核心理念和实践范式。从开发瓶颈和服务演进的角度讲述「<strong>最后一个</strong>」mock 方案。</p>\n<h3>《蚂蚁国际前端工程体系》</h3>\n<p>分享时间：14:50 - 15:30</p>\n<p>主讲人介绍：徐达峰(<a href=\"https://github.com/xudafeng\">@xudafeng</a>) - 蚂蚁金服前端技术专家，阿里开源测试框架 <a href=\"https://github.com/alibaba/macaca\">Macaca</a> 作者，<a href=\"https://github.com/xudafeng/autoresponsive-react\">autoresponsive-react</a> 作者。</p>\n<p><img src=\"//static.cnodejs.org/FgCUNY56nLYcXl7pXP1zaCIKNmOJ\" alt=\"1536221094365-b2da0ffa-9103-478b-bd39-c8de3f06a0f2.png | left\"></p>\n<p>内容：介绍蚂蚁金服国际部门在国际化与本土化进程中遇到的挑战和成长。剖析中国技术出海的特点和如何快速构建合适的前端工程体系，也包括工具体系、持续交付、自动化测试等几个方向上的实践和思考。同时也会涉及 Macaca 技术生态的国际化成长。</p>\n<h3>《Node.js 微服务实践》</h3>\n<p>PPT：<a href=\"https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925145070-a192b890-1cbb-47da-bd4d-842671ceac98.pdf\" title=\"size:5178626\">download: Node.js 微服务实践.pdf</a></p>\n<p>分享时间：15:40 - 16:20</p>\n<p>主讲人介绍：高晓晨(<a href=\"https://github.com/gxcsoccer\">@gxcsoccer</a>) - 蚂蚁金服前端技术专家，企业级 Web 框架应用框架 <a href=\"https://github.com/eggjs\">Egg.js</a> 核心成员，<a href=\"https://github.com/alipay/sofa-rpc-node\">sofa-rpc-node</a> 作者。</p>\n<p><img src=\"//static.cnodejs.org/Fk0AYqZmVT5QmcnpFKO8AKCGjM-l\" alt=\"1536222500407-c710cca5-36d4-4685-a9d2-ba34163c39ff.png | left\"></p>\n<p>内容：介绍金服如何用 Node.js 来实现微服务，包括 RPC 原理、服务发现、负载均衡等话题。同时会介绍一下如何使用和扩展我们开源的 <a href=\"https://github.com/alipay/sofa-rpc-node\">sofa-rpc-node</a> 项目来帮助外部实现 RPC，为系统架构带来新活力。</p>\n<h3>《GraphQL 生态介绍》</h3>\n<p>PPT：<a href=\"https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925158919-2cd3bd39-31bd-4377-b347-33213489cde2.pdf\" title=\"size:4043353\">download: GraphQL.pdf</a></p>\n<p>分享时间：16:30 - 17:10</p>\n<p>主讲人介绍：张开宇(<a href=\"https://github.com/zhangkaiyulw\">@zhangkaiyulw</a>) - 前 Oracle 北京，香港 Beecrazy 员工。Ruby on Rails 贡献者之一。在后端，前端，移动端，以及 React Native 开发上，有丰富的经验。曾尝试将 iOS 系统的 Cocoa Touch API 风格移植到 HTML 网页中，并开发了基于其的一款国际象棋应用。有丰富大量的开源代码。</p>\n<p><img src=\"//static.cnodejs.org/Fln08dUMEWfnEFwd4gmpC8QJJP9O\" alt=\"1536220909272-71b9e8f9-1665-4b84-85a0-26d686b8a7c5.png | left\"></p>\n<p>内容：本次演讲介绍实现GraphQL API的工具，包括 apollo-server、merge-graphql-schemas、graphql-middleware、amur 脚手架工具以及他们的用法。并五分钟内演示带有上传功能，混合字段类型的，带有数据关联的复杂系统的 API。</p>\n<h3>《 Megalo - 考拉的小程序解决方案》</h3>\n<p>PPT：<a href=\"https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925172399-4ed1c6cc-479e-4e4a-b537-0b4353da8198.pdf\" title=\"size:1943122\">download: megalo-考拉的小程序解决方案.pdf</a></p>\n<p>分享时间：17:20 - 18:00</p>\n<p>主讲人介绍：网易考拉前端工程师，吴子然<a href=\"https://github.com/elcarim5efil\">@elcarim</a>，<a href=\"https://github.com/kaola-fed/mpregular\">mpregular</a>、<a href=\"https://github.com/kaola-fed/megalo\">megalo</a> 核心开发。</p>\n<p><img src=\"//static.cnodejs.org/Fh_VjuoZMUe_g5Tof53qU1iZ-wh_\" alt=\"网易考拉_吴子然.jpeg | left\"></p>\n<p>内容：介绍考拉的小程序框架发展历程，我们是如何在现有框架上做改造，在小程序上支持更多的 Vue 特性，让跨端开发变得更简单。</p>\n<hr>\n<h2>现场照片</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924550598-bf24d186-3ff1-494d-a4f2-3702fac3aa6a.png\" alt=\"image.png | left | 827x272\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924563365-f723e300-5223-4fc4-8751-416c98b9afd3.png\" alt=\"image.png | left | 827x257\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924608159-042af9f1-0880-4003-a3ec-2697cf38bf18.png\" alt=\"image.png | left | 827x620\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924578426-21656c2f-8b66-4452-915d-51b3320fbabb.png\" alt=\"image.png | left | 827x620\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924629304-e8547f9d-2bed-4b1c-bf50-cfbdd52f9d8e.png\" alt=\"image.png | left | 827x620\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537926665393-17bb8bbb-d585-4bc9-a7cc-80cad0d6596f.png\" alt=\"image.png | left | 827x602\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924638476-713a60a3-43d9-4261-9f2e-672e4cf4487d.png\" alt=\"image.png | left | 827x620\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537924701018-cd3800f5-3940-4877-844c-29b7f1015e37.png\" alt=\"image.png | left | 827x615\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537926870402-15f18f5d-dbe9-4faf-a1b6-301e7fe5fe67.png\" alt=\"image.png | left | 827x606\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537926843721-002a0b79-235d-456e-8daf-5f3fde47b5b0.png\" alt=\"image.png | left | 827x604\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1537925309980-a2262bf0-d3e6-4152-8150-1c8487cfda69.png\" alt=\"image.png | left | 827x607\"></p>\n<h3>特别感谢浙大软件学院对本次活动提供场地支持！</h3>\n<hr>\n<h2>关于 NodeParty</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/95383/1536228236464-a496d8a0-4862-4946-af56-b55fb7c68af3.png\" alt=\"image | center\"></p>\n<p>NodeParty 品牌诞生于 CNode 社区，杭州 NodeParty 是由大搜车（Souche Inc.）发起的一个面向 Node.js 爱好者的技术分享聚会，希望能够构建一个持续的分享学习的平台，一起发展 Node.js 生态。</p>\n</div>",
            "title": "第七期杭州 Node Party 回顾【附PPT】",
            "last_reply_at": "2018-10-17T07:50:19.775Z",
            "good": false,
            "top": true,
            "reply_count": 60,
            "visit_count": 8229,
            "create_at": "2018-09-06T12:35:36.197Z",
            "author": {
                "loginname": "yllziv",
                "avatar_url": "https://avatars1.githubusercontent.com/u/11460601?v=4&s=120"
            }
        },
        {
            "id": "5bca0b3f37a6965f590523ea",
            "author_id": "5b6501ebb71aedfe4c126728",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我已经自己删除了所有发言，就差注销帐号了，设置里没找到注销帐号。 我感觉我高估了这个论坛里的总体水平，还是去专业的提问网站好，这里太水了。 所以请版主帮忙注销下谢谢！我发完这个帖子就退出登陆了，大家就别回复了。</p>\n</div>",
            "title": "请问如何注销帐号？或者请版主帮忙注销下谢谢！",
            "last_reply_at": "2018-10-20T04:47:59.803Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 97,
            "create_at": "2018-10-19T16:50:07.059Z",
            "author": {
                "loginname": "jinkankakushoujo",
                "avatar_url": "https://avatars1.githubusercontent.com/u/32699474?v=4&s=120"
            }
        },
        {
            "id": "5bcab2c337a6965f590523f0",
            "author_id": "5a7a5d505321b5396004ec1e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>Nest.js 是用于构建高效且可伸缩 Web 应用程序的渐进式 Node.js 框架。</p>\n<ul>\n<li>\n<p>完美支持 Typescript</p>\n</li>\n<li>\n<p>面向 AOP 编程</p>\n</li>\n<li>\n<p>支持 typeorm</p>\n</li>\n<li>\n<p>Node.js 版的 spring</p>\n</li>\n<li>\n<p>构建微服务应用</p>\n</li>\n</ul>\n<h2>本次更新如下：</h2>\n<h3>Bug 修复</h3>\n<p><strong>特征</strong></p>\n<p>common：更新axios到最新版本＃1152\n核心：将模块上下文名称添加到UnknownDependenciesMessage ＃1143\n核心：property-based 的注入支持＃1172\n核心：动态提供者功能ModuleRef.create() ＃1172\n微服务：RabbitMQ支持＃1170\n微服务：支持Nats transport ＃1175中的队列</p>\n<p><strong>Bug修复</strong>\n核心：允许导出抽象提供者＃1208</p>\n<h2>相关地址</h2>\n<p>中文文档：<a href=\"https://docs.nestjs.cn/\">https://docs.nestjs.cn/</a></p>\n<p>英文原版文档：<a href=\"https://docs.nestjs.com/\">https://docs.nestjs.com/</a></p>\n<p>GitHub 地址：<a href=\"https://github.com/nestjs/nest\">https://github.com/nestjs/nest</a></p>\n</div>",
            "title": "Nest.js 5.4.0 发布，支持微服务的 AOP 风格 Node.js 框架",
            "last_reply_at": "2018-10-20T04:44:51.210Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 27,
            "create_at": "2018-10-20T04:44:51.210Z",
            "author": {
                "loginname": "zuohuadong",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"
            }
        },
        {
            "id": "5bca8cb19545eaf107b9cceb",
            "author_id": "5bc96744ede204052db8064d",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>在与微信支付的通信中，微信方使用的是xml格式的报文，那nodejs端要返回xml格式的报文应该如何做呢？（刚刚学习nodejs，感觉这应该是个很简单的问题吧，但是在网上没找到答案，也许是自己的搜商太低。）</p>\n</div>",
            "title": "nodejs如何发送xml格式的报文",
            "last_reply_at": "2018-10-20T02:54:06.546Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 50,
            "create_at": "2018-10-20T02:02:25.053Z",
            "author": {
                "loginname": "pengnianrong",
                "avatar_url": "https://avatars1.githubusercontent.com/u/7850227?v=4&s=120"
            }
        },
        {
            "id": "5bc9bb2537a6965f590523d5",
            "author_id": "5110f2bedf9e9fcc584e4677",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2><a href=\"https://github.com/nswbmw/kless\">Kless</a></h2>\n<p>一个受 FaaS 启发的框架，源码总共 60 行，废话不多说了，用法很简单。\n欢迎吐槽~</p>\n<h3>Installation</h3>\n<pre class=\"prettyprint language-sh\"><code>$ npm i @nswbmw&#x2F;kless --save\n</code></pre><h3>Example</h3>\n<pre class=\"prettyprint language-js\"><code>const Kless = require(&#x27;@nswbmw&#x2F;kless&#x27;)\nconst app = new Kless()\n\napp.register({\n  name: &#x27;User.getUserById&#x27;,\n  handler: async (ctx, next) =&gt; {\n    ctx.body = ctx.query.id\n  }\n})\n\napp.listen(3000)\n\n&#x2F;*\n$ curl localhost:3000&#x2F;User.getUserById?id=123\n123\n*&#x2F;\n</code></pre><p><strong>Validator</strong></p>\n<pre class=\"prettyprint language-js\"><code>const Kless = require(&#x27;@nswbmw&#x2F;kless&#x27;)\nconst app = new Kless()\n\napp.register({\n  name: &#x27;User.getUserById&#x27;,\n  validate: {\n    query: {\n      id: { type: Kless.Types.Number, required: true }\n    }\n  },\n  handler: async (ctx, next) =&gt; {\n    ctx.body = ctx.query.id\n  }\n})\n\napp.listen(3000)\n\n&#x2F;*\n$ curl localhost:3000&#x2F;User.getUserById\n($.query.id: undefined) ✖ (required: true)\n$ curl localhost:3000&#x2F;User.getUserById?id=test\n($.query.id: &quot;test&quot;) ✖ (type: Number)\n$ curl localhost:3000&#x2F;User.getUserById?id=123\n123\n*&#x2F;\n</code></pre><p>More validators usage see <a href=\"https://github.com/nswbmw/another-json-schema\">another-json-schema</a>.</p>\n<p><strong>Array handlers</strong></p>\n<pre class=\"prettyprint language-js\"><code>const bodyParser = require(&#x27;koa-bodyparser&#x27;)\nconst Kless = require(&#x27;@nswbmw&#x2F;kless&#x27;)\nconst app = new Kless()\n\napp.register({\n  name: &#x27;User.createUser&#x27;,\n  handler: [\n    bodyParser(),\n    async (ctx, next) =&gt; {\n      ctx.body = ctx.request.body\n    }\n  ]\n})\n\napp.listen(3000)\n</code></pre><h3>Test</h3>\n<pre class=\"prettyprint language-sh\"><code>$ npm test (coverage 100%)\n</code></pre><h3>License</h3>\n<p>MIT</p>\n</div>",
            "title": "Kless——一个受 FaaS 启发的框架",
            "last_reply_at": "2018-10-20T01:42:09.148Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 148,
            "create_at": "2018-10-19T11:08:21.976Z",
            "author": {
                "loginname": "nswbmw",
                "avatar_url": "https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"
            }
        },
        {
            "id": "5bca84a237a6965f590523eb",
            "author_id": "5ad86092a7d228c16b987042",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>const { Router } = require(&#x27;restify-router&#x27;);\nconst router = new Router();\nrouter.post(&#x27;&#x27;, async (req, res, next) =&gt; {});\n</code></pre><p>这种写法有没有问题？</p>\n</div>",
            "title": "node router",
            "last_reply_at": "2018-10-20T01:28:02.045Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 47,
            "create_at": "2018-10-20T01:28:02.045Z",
            "author": {
                "loginname": "dingyuanwu",
                "avatar_url": "https://avatars0.githubusercontent.com/u/27721756?v=4&s=120"
            }
        },
        {
            "id": "5bc1893815e4fd1923f48ea2",
            "author_id": "57346bbf32bf2c90579f529f",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>rt，希望demo</p>\n</div>",
            "title": "那位小伙伴有处理ueditor分文本上传图片跨域的问题，后端egg，前端vue，前后端部署在不同服务器上，域名和端口都不一样。",
            "last_reply_at": "2018-10-20T01:11:07.546Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 190,
            "create_at": "2018-10-13T05:57:12.864Z",
            "author": {
                "loginname": "dpc761218914",
                "avatar_url": "https://avatars3.githubusercontent.com/u/16233212?v=4&s=120"
            }
        },
        {
            "id": "5bca63299545eaf107b9cce7",
            "author_id": "58dc892303d476b42d34c8bd",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/3dgen/cppwasm-book\">https://github.com/3dgen/cppwasm-book</a></p>\n</div>",
            "title": "开源图书：《C/C++面向wasm编程》",
            "last_reply_at": "2018-10-19T23:05:13.831Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 60,
            "create_at": "2018-10-19T23:05:13.831Z",
            "author": {
                "loginname": "chai2010",
                "avatar_url": "https://avatars1.githubusercontent.com/u/2295542?v=4&s=120"
            }
        },
        {
            "id": "5bca0b2437a6965f590523e9",
            "author_id": "58b7c78ce418a986315f3aaf",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>author： HKK\ndate：2018-10-20\nsource：<a href=\"https://github.com/zhanghengxin/record/wiki/node-%E6%BA%90%E7%A0%81-%E4%B8%8E-js-%E5%8D%8F%E5%90%8C%E8%B0%83%E8%AF%95\">https://github.com/zhanghengxin/record/wiki/node-源码-与-js-协同调试</a></p>\n<h1>搭建 C++ 运行环境</h1>\n<blockquote>\n<p>Mac + CLion\nCLion 是一款 <a href=\"https://en.wikipedia.org/wiki/JetBrains#CLion\">傻啦吧唧，这不是论文</a>\n如果你想要 <a href=\"https://www.jetbrains.com/clion/\">免费的，</a> 没有\n但是里面包含全部C++编译的玩意儿。。。</p>\n</blockquote>\n<h1>搭建项目</h1>\n<p>安装完毕你需要 <a href=\"https://github.com/nodejs/node.git\">node 源码</a>\n下载过程十分缓慢，我计算了一下，10kb/s，大概是五天时间。\n你可以 找 <strong>远航</strong> ^我同事，你不认识很正常^ 他可以翻墙 <code>只能用绿灯</code>\n然后将node-master 文件夹放入你的项目中\n在此之前，因为需要编译，在你的 terminal 输入</p>\n<pre class=\"prettyprint\"><code>.&#x2F;configure --debug\n</code></pre><p>然后输入</p>\n<pre class=\"prettyprint\"><code>make -C out BUILDTYPE=Debug -j 4\n</code></pre><blockquote>\n<p>-j 4 是指进程数，你可以往多了写，但容易报错</p>\n</blockquote>\n<blockquote>\n<p>编译过程十分漫长，你可以看个“浙江卫视”</p>\n</blockquote>\n<h1>配置debug文件</h1>\n<p>兄弟们没有图片你们是不是看的很心酸。。。&lt;br&gt;\n没办法，还得上传。。。&lt;br&gt;\n编译之后，会生成node 运行文件\n<img src=\"https://upload-images.jianshu.io/upload_images/3809332-78e2c113f7b10312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"编译之后，会生成node 运行文件\">\n<strong>Program arguments</strong>\n运行执行文件的喽喽，都是node 命令 的执行参数</p>\n<pre class=\"prettyprint\"><code>--inspect=127.0.0.1:9229 \n</code></pre><p>这个配置是为了在谷歌浏览器上调试\n详情请参考，<a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">node 官方文档</a></p>\n<h1>js调试配置</h1>\n<p>首先，在你的js运行文件上加入debugger &lt;br&gt;\n然后，打开，<a href>inspect</a>, 地址是chrome://inspect/#devices</p>\n<h1>运行debug</h1>\n<p>点击这个小虫子\n<img src=\"https://upload-images.jianshu.io/upload_images/3809332-5b85c10b42006845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\">\n这样，js 脚本就和 node 源码同时 调试了。</p>\n<p>过程。。。一般般\n就是时间慢\n有问题，请留言</p>\n<p><a href=\"http://creativecommons.org/licenses/by-nc-sa/3.0/\">知识共享许可协议</a>\n本作品采用知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议进行许可。</p>\n</div>",
            "title": "node 源码 与 js 协同调试",
            "last_reply_at": "2018-10-19T16:49:40.613Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 151,
            "create_at": "2018-10-19T16:49:40.613Z",
            "author": {
                "loginname": "zhongguozhe",
                "avatar_url": "https://avatars1.githubusercontent.com/u/24197448?v=4&s=120"
            }
        },
        {
            "id": "5bc9f54a37a6965f590523e3",
            "author_id": "5aec22a00a36e5312d6eccfc",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>一个使用的例子：<a href=\"https://sourcegraph.com/github.com/nuysoft/Mock/-/blob/src/mock/random/image.js#L252\">https://sourcegraph.com/github.com/nuysoft/Mock/-/blob/src/mock/random/image.js#L252</a></p>\n<p>但是执行的时候会报错：module.require is not a function，相关issue：<a href=\"https://github.com/nuysoft/Mock/issues/222\">https://github.com/nuysoft/Mock/issues/222</a></p>\n<p>官方文档里面确实有这个方法(8和10的文档里都有)，<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/modules.html#modules_module_require_id%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E6%88%91%E6%B2%A1%E7%9C%8B%E6%98%8E%E7%99%BD%EF%BC%9A\">https://nodejs.org/dist/latest-v8.x/docs/api/modules.html#modules_module_require_id，但是它的使用说明我没看明白：</a></p>\n<p>Note: In order to do this, it is necessary to get a reference to the module object. Since require() returns the module.exports, and the module is typically only available within a specific module’s code, it must be explicitly exported in order to be used.</p>\n<p>有人使用过这个方法吗？如何使用呢？它和require()到底有何区别？</p>\n</div>",
            "title": "module.require是如何使用的？",
            "last_reply_at": "2018-10-19T15:16:26.309Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 70,
            "create_at": "2018-10-19T15:16:26.309Z",
            "author": {
                "loginname": "athrunsun",
                "avatar_url": "https://avatars3.githubusercontent.com/u/1920454?v=4&s=120"
            }
        },
        {
            "id": "5bc7fb6137a6965f59052339",
            "author_id": "536af53d9968d761330390f7",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2><a href=\"https://promotion.aliyun.com/ntms/act/enterprise-discount.html?userCode=n2hxqpjv\">企业级ECS云服务器特惠</a></h2>\n<h2><a href=\"https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=n2hxqpjv\">阿里云￥1888元优惠券领取</a></h2>\n<h2><a href=\"https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=n2hxqpjv\">ECS云服务器2折起，优惠配置多选1</a></h2>\n</div>",
            "title": "阿里云企业级服务器特惠",
            "last_reply_at": "2018-10-19T14:55:56.828Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 736,
            "create_at": "2018-10-18T03:17:53.091Z",
            "author": {
                "loginname": "skythinking",
                "avatar_url": "https://avatars3.githubusercontent.com/u/7401507?v=4&s=120"
            }
        },
        {
            "id": "5ab3166be7b166bb7b9eccf7",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>",
            "title": "【全文】狼叔：如何正确的学习Node.js",
            "last_reply_at": "2018-10-19T12:37:42.558Z",
            "good": true,
            "top": false,
            "reply_count": 82,
            "visit_count": 38481,
            "create_at": "2018-03-22T02:35:23.073Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        },
        {
            "id": "5b630389b71aedfe4c1266a2",
            "author_id": "5b62fab258db3ccf66a4516b",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>近期在学习node.js，由于自己是初学者，看了《Node.js开发指南》和 《Node.js开发实战》上的一些基础的东西，《深入浅出 Node.js》看起来是很吃力，最近试着用Express开发自己的一个 个人博客系统，刚刚开始，就感觉很吃力，最近就在想该怎么来学习，希望曾经和我有相同问题的朋友解答下我的疑惑，学习路线很迷茫啊。。。</p>\n</div>",
            "title": "node.js的入门（萌新）",
            "last_reply_at": "2018-10-19T12:09:47.465Z",
            "good": false,
            "top": false,
            "reply_count": 25,
            "visit_count": 2515,
            "create_at": "2018-08-02T13:13:45.110Z",
            "author": {
                "loginname": "remembergf",
                "avatar_url": "https://avatars1.githubusercontent.com/u/34055216?v=4&s=120"
            }
        },
        {
            "id": "5bc933129545eaf107b9cc84",
            "author_id": "5bc932c337a6965f59052399",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>我们团队现在开发的node项目都是基于koa框架实现的，虽然现在也形成了一套团队内的标准，但是在开发的过程中也遇到了一些问题：</p>\n<ol>\n<li>由于没有统一的规范，新人上手和沟通成本比较高，容易出现错误</li>\n<li>仅局限于目前需求进行设计，扩展性不高</li>\n<li>系统部署及配置信息维护成本较高</li>\n<li>业务代码实现起来不是很优雅，比如（1）关于文件的引入，到处的require，经常会出现忘记require或者多余的require问题（2）因为在当前请求的上下文ctx中封装了很多有用的数据，包括response，request以及在中间件中处理的中间结果，但是如果我们想在service以下的js文件中获取到ctx必须需要主动以函数参数的方式传进去，不是特别友好</li>\n</ol>\n<p>而阿里团队基于koa开发的egg框架，基于一套统一约定进行应用开发，很好的解决了我们遇到的一些问题，看了<a href=\"https://eggjs.org/zh-cn/intro/index.html\">egg的官方开发文档</a>后，比较好奇它是怎么把controller，service，middleware，extend，route.js等关联在一起并加载的，后面看了源码发现这块逻辑主要在<a href=\"https://github.com/eggjs/egg-core\">egg-core</a>这个库中实现的，所以关于自己对egg-core源码的学习收获做一个总结:</p>\n<h3>egg-core是什么</h3>\n<h5>应用、框架、插件之间的关系</h5>\n<p>在学习egg-core是什么之前，我们先了解一下关于Egg框架中应用，框架，插件这三个概念及其之间的关系：</p>\n<ul>\n<li>一个应用必须指定一个框架才能运行起来，根据需要我们可以给一个应用配置多个不同的插件</li>\n<li>插件只完成特定独立的功能，实现即插即拔的效果</li>\n<li>框架是一个启动器，必须有它才能运行起来。框架还是一个封装器，它可以在已有框架的基础上进行封装，框架也可以配置插件，其中Egg，EggCore都是框架</li>\n<li>在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承</li>\n<li>框架/应用/插件的关于service/controler/config/middleware的目录结构配置基本相同，称之为加载单元（loadUnit），包括后面源码分析中的getLoadUnits都是为了获取这个结构</li>\n</ul>\n<pre class=\"prettyprint\"><code># 加载单元的目录结构如下图，其中插件和框架没有controller和router.js\n# 这个目录结构很重要，后面所有的load方法都是针对这个目录结构进行的\n        loadUnit\n        ├── package.json\n        ├── app\n        │   ├── extend\n        │   |   ├── helper.js\n        │   |   ├── request.js\n        │   |   ├── response.js\n        │   |   ├── context.js\n        │   |   ├── application.js\n        │   |   └── agent.js\n        │   ├── service\n        |   ├── controller\n        │   ├── middleware\n        │   └── router.js\n        └── config\n            ├── config.default.js\n            ├── config.prod.js\n            ├── config.test.js\n            ├── config.local.js\n            └── config.unittest.js\n</code></pre><h5>eggCore的主要工作</h5>\n<p>egg.js的大部分核心代码实现都在<a href=\"https://github.com/eggjs/egg-core\">egg-core库</a>中，egg-core主要export四个对象:</p>\n<ul>\n<li>EggCore类：继承于Koa，做一些初始化工作，EggCore中最主要的一个属性是loader，也就是egg-core的导出的第二个类EggLoader的实例</li>\n<li>EggLoader类：整个框架目录结构（controller，service，middleware，extend，route.js）的加载和初始化工作都在该类中实现的，主要提供了几个load函数(loadPlugin,loadConfig,loadMiddleware,loadService,loadController,loadRouter等)，这些函数会根据指定目录结构下文件输出形式不同进行适配，最终挂载输出内容。</li>\n<li>BaseContextClass类：这个类主要是为了我们在使用框架开发时，在controller和service作为基类使用，只有继承了该类，我们才可以通过this.ctx获取到当前请求的上下文对象</li>\n<li>utils对象：几个主要的函数，包括转换成中间件函数middleware，根据不同类型文件获取文件导出内容函数loadFile等</li>\n</ul>\n<p>所以egg-core做的主要事情就是根据loadUnit的目录结构规范，将目录结构中的config，controller，service，middleware，plugin，router等文件load到app或者context上，开发人员只要按照这套约定规范，就可以很方便进行开发，以下是EggCore的exports对象源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>\n&#x2F;&#x2F;egg-core源码 -&gt; index文件导出的数据结构\nconst EggCore = require(&#x27;.&#x2F;lib&#x2F;egg&#x27;);\nconst EggLoader = require(&#x27;.&#x2F;lib&#x2F;loader&#x2F;egg_loader&#x27;);\nconst BaseContextClass = require(&#x27;.&#x2F;lib&#x2F;utils&#x2F;base_context_class&#x27;);\nconst utils = require(&#x27;.&#x2F;lib&#x2F;utils&#x27;);\n\nmodule.exports = {\n  EggCore,\n  EggLoader,\n  BaseContextClass,\n  utils,\n};\n\n</code></pre><h3>EggLoader的具体实现源码学习</h3>\n<h5>EggCore类源码学习</h5>\n<p>EggCore类是算是上文提到的框架范畴，它从Koa类继承而来，并做了一些初始化工作，其中有三个主要属性是：</p>\n<ul>\n<li>loader：这个对象是EggLoader的实例，定义了多个load函数，用于对loadUnit目录下的文件进行加载，后面后专门讲这个类的是实现</li>\n<li>router：是EggRouter类的实例，从<a href=\"https://github.com/alexmingoia/koa-router\">koa-router</a>继承而来，用于egg框架的路由管理和分发，这个类的实现在后面的loadRouter函数会有说明</li>\n<li>lifecycle：这个属性用于app的生命周期管理，由于和整个文件加载逻辑关系不大，所以这里不作说明</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; EggCore类的部分实现\n\nconst KoaApplication = require(&#x27;koa&#x27;);\nconst EGG_LOADER = Symbol.for(&#x27;egg#loader&#x27;);\n\nclass EggCore extends KoaApplication {\n    constructor(options = {}) {\n        super();\n        const Loader = this[EGG_LOADER];\n        &#x2F;&#x2F;初始化loader对象\n        this.loader = new Loader({\n            baseDir: options.baseDir,          &#x2F;&#x2F;项目启动的根目录\n            app: this,                         &#x2F;&#x2F;EggCore实例本身\n            plugins: options.plugins,          &#x2F;&#x2F;自定义插件配置信息，设置插件配置信息有多种方式，后面我们会讲\n            logger: this.console,             \n            serverScope: options.serverScope, \n        });\n    }\n    get [EGG_LOADER]() {\n        return require(&#x27;.&#x2F;loader&#x2F;egg_loader&#x27;);\n    }\n    &#x2F;&#x2F;router对象\n    get router() {\n        if (this[ROUTER]) {\n          return this[ROUTER];\n        }\n        const router = this[ROUTER] = new Router({ sensitive: true }, this);\n        &#x2F;&#x2F; register router middleware\n        this.beforeStart(() =&gt; {\n          this.use(router.middleware());\n        });\n        return router;\n    }\n    &#x2F;&#x2F;生命周期对象初始化\n    this.lifecycle = new Lifecycle({\n        baseDir: options.baseDir,\n        app: this,\n        logger: this.console,\n    });\n}\n\n</code></pre><h5>EggLoader类源码学习</h5>\n<p>如果说eggCore是egg框架的精华所在，那么eggLoader可以说是eggCore的精华所在，下面我们主要从EggLoader的实现细节开始学习eggCore这个库：</p>\n<p>EggLoader首先对app中的一些基本信息（pkg/eggPaths/serverEnv/appInfo/serverScope/baseDir等）进行整理，并且定义一些基础共用函数(getEggPaths/getTypeFiles/getLoadUnits/loadFile)，所有的这些基础准备都是为了后面介绍的几个load函数作准备，我们下面看一下其基础部分的实现：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; EggLoader中基本属性和基本函数的实现\n\nclass EggLoader {\n    constructor(options) {\n        this.options = options;\n        this.app = this.options.app;\n        &#x2F;&#x2F;pkg是根目录的package.json输出对象\n        this.pkg = utility.readJSONSync(path.join(this.options.baseDir, &#x27;package.json&#x27;));\n        &#x2F;&#x2F;eggPaths是所有框架目录的集合体，虽然我们上面提到一个应用只有一个框架，但是框架可以在框架的基础上实现多级继承，所以是多个eggPath\n        &#x2F;&#x2F;在实现框架类的时候，必须指定属性Symbol.for(&#x27;egg#eggPath&#x27;)，这样才能找到框架的目录结构\n        &#x2F;&#x2F;下面有关于getEggPaths函数的实现分析\n        this.eggPaths = this.getEggPaths();\n        this.serverEnv = this.getServerEnv();\n        &#x2F;&#x2F;获取app的一些基本配置信息(name,baseDir,env,scope,pkg等)\n        this.appInfo = this.getAppInfo();\n        this.serverScope = options.serverScope !== undefined\n            ? options.serverScope\n            : this.getServerScope();\n    }\n    &#x2F;&#x2F;递归获取继承链上所有eggPath\n    getEggPaths() {\n        const EggCore = require(&#x27;..&#x2F;egg&#x27;);\n        const eggPaths = [];\n        let proto = this.app;\n        &#x2F;&#x2F;循环递归的获取原型链上的框架Symbol.for(&#x27;egg#eggPath&#x27;)属性\n        while (proto) {\n            proto = Object.getPrototypeOf(proto);\n            &#x2F;&#x2F;直到proto属性等于EggCore本身，说明到了最上层的框架类，停止循环\n            if (proto === Object.prototype || proto === EggCore.prototype) {\n                break;\n            }\n            const eggPath = proto[Symbol.for(&#x27;egg#eggPath&#x27;)];\n            const realpath = fs.realpathSync(eggPath);\n            if (!eggPaths.includes(realpath)) {\n                eggPaths.unshift(realpath);\n            }\n        }\n        return eggPaths;\n    }\n    \n    &#x2F;&#x2F;函数输入：config或者plugin；函数输出：当前环境下的所有配置文件\n    &#x2F;&#x2F;该函数会根据serverScope，serverEnv的配置信息，返回当前环境对应filename的所有配置文件\n    &#x2F;&#x2F;比如我们的serverEnv=prod，serverScope=online，那么返回的config配置文件是[&#x27;config.default&#x27;, &#x27;config.prod&#x27;, &#x27;config.online_prod&#x27;]\n    &#x2F;&#x2F;这几个文件加载顺序非常重要，因为最终获取到的config信息会进行深度的覆盖，后面的文件信息会覆盖前面的文件信息\n    getTypeFiles(filename) {\n        const files = [ &#96;${filename}.default&#96; ];\n        if (this.serverScope) files.push(&#96;${filename}.${this.serverScope}&#96;);\n        if (this.serverEnv === &#x27;default&#x27;) return files;\n\n        files.push(&#96;${filename}.${this.serverEnv}&#96;);\n        if (this.serverScope) files.push(&#96;${filename}.${this.serverScope}_${this.serverEnv}&#96;);\n        return files;\n    }\n    \n    &#x2F;&#x2F;获取框架、应用、插件的loadUnits目录集合，上文有关于loadUnits的说明\n    &#x2F;&#x2F;这个函数在下文中介绍的loadSerivce,loadMiddleware,loadConfig,loadExtend中都会用到，因为plugin，framework，app中都会有关系这些信息的配置\n    getLoadUnits() {\n        if (this.dirs) {\n            return this.dirs;\n        }\n        const dirs = this.dirs = [];\n        &#x2F;&#x2F;插件目录，关于orderPlugins会在后面的loadPlugin函数中讲到\n        if (this.orderPlugins) {\n            for (const plugin of this.orderPlugins) {\n                dirs.push({\n                    path: plugin.path,\n                    type: &#x27;plugin&#x27;,\n                });\n            }\n        }\n        &#x2F;&#x2F;框架目录\n        for (const eggPath of this.eggPaths) {\n            dirs.push({\n                path: eggPath,\n                type: &#x27;framework&#x27;,\n            });\n        }\n        &#x2F;&#x2F;应用目录\n        dirs.push({\n            path: this.options.baseDir,\n            type: &#x27;app&#x27;,\n        });\n        return dirs;\n    }\n\n    &#x2F;&#x2F;这个函数用于读取某个LoadUnit下的文件具体内容，包括js文件，json文件及其它普通文件\n    loadFile(filepath, ...inject) {\n        if (!filepath || !fs.existsSync(filepath)) {\n            return null;\n        }\n        if (inject.length === 0) inject = [ this.app ];\n        let ret = this.requireFile(filepath);\n        &#x2F;&#x2F;这里要注意，如果某个js文件导出的是一个函数，且不是一个Class，那么Egg认为这个函数的格式是：app =&gt; {},输入是EggCore实例，输出是真正需要的信息\n        if (is.function(ret) &amp;&amp; !is.class(ret)) {\n            ret = ret(...inject);\n        }\n        return ret;\n    }\n}\n\n</code></pre><h3>各种loader函数的实现源码分析</h3>\n<p>上文中只是介绍了EggLoader中的一些基本属性和函数，那么如何将LoadUnits中的不同类型的文件分别加载进来呢，egg-core中每一种类型（service/controller等）的文件加载都在一个独立的文件里实现。比如我们加载controller文件可以通过’./mixin/controller’目录下的loadController完成，加载service文件可以通过’./mixin/service’下的loadService函数完成，然后将这些方法挂载EggLoader的原型上，这样就可以直接在EggLoader的实例上使用</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; 混入不同目录文件的加载方法到EggLoader的原型上\n\nconst loaders = [\n  require(&#x27;.&#x2F;mixin&#x2F;plugin&#x27;),            &#x2F;&#x2F;loadPlugin方法\n  require(&#x27;.&#x2F;mixin&#x2F;config&#x27;),            &#x2F;&#x2F;loadConfig方法\n  require(&#x27;.&#x2F;mixin&#x2F;extend&#x27;),            &#x2F;&#x2F;loadExtend方法\n  require(&#x27;.&#x2F;mixin&#x2F;custom&#x27;),            &#x2F;&#x2F;loadCustomApp和loadCustomAgent方法\n  require(&#x27;.&#x2F;mixin&#x2F;service&#x27;),           &#x2F;&#x2F;loadService方法\n  require(&#x27;.&#x2F;mixin&#x2F;middleware&#x27;),        &#x2F;&#x2F;loadMiddleware方法\n  require(&#x27;.&#x2F;mixin&#x2F;controller&#x27;),        &#x2F;&#x2F;loadController方法\n  require(&#x27;.&#x2F;mixin&#x2F;router&#x27;),            &#x2F;&#x2F;loadRouter方法\n];\n\nfor (const loader of loaders) {\n  Object.assign(EggLoader.prototype, loader);\n}\n</code></pre><p>我们按照上述loaders中定义的元素顺序，对各个load函数的源码实现进行一一分析：</p>\n<h5>loadPlugin函数</h5>\n<p>插件是一个迷你的应用，没有包含router.js和controller文件夹，我们上文也提到，应用和框架里都可以包含插件，而且还可以通过环境变量和初始化参数传入，关于插件初始化的几个参数：</p>\n<ul>\n<li>enable： 是否开启插件</li>\n<li>env：  选择插件在哪些环境运行</li>\n<li>path： 插件的所在路径</li>\n<li>package： 和path只能设置其中一个，根据package名称去node_modules里查询plugin，后面源码里有详细说明</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; loadPlugin函数部分源码\n\nloadPlugin() {\n    &#x2F;&#x2F;加载应用目录下的plugins\n    &#x2F;&#x2F;readPluginConfigs这个函数会先调用我们上文提到的getTypeFiles获取到app目录下所有的plugin文件名，然后按照文件顺序进行加载并合并，并规范plugin的数据结构\n    const appPlugins = this.readPluginConfigs(path.join(this.options.baseDir, &#x27;config&#x2F;plugin.default&#x27;));\n\n    &#x2F;&#x2F;加载框架目录下的plugins\n    const eggPluginConfigPaths = this.eggPaths.map(eggPath =&gt; path.join(eggPath, &#x27;config&#x2F;plugin.default&#x27;));\n    const eggPlugins = this.readPluginConfigs(eggPluginConfigPaths);\n\n    &#x2F;&#x2F;可以通过环境变量EGG_PLUGINS对配置plugins，从环境变量加载plugins\n    let customPlugins;\n    if (process.env.EGG_PLUGINS) {\n      try {\n        customPlugins = JSON.parse(process.env.EGG_PLUGINS);\n      } catch (e) {\n        debug(&#x27;parse EGG_PLUGINS failed, %s&#x27;, e);\n      }\n    }\n\n    &#x2F;&#x2F;从启动参数options里加载plugins\n    &#x2F;&#x2F;启动参数的plugins和环境变量的plugins都是自定义的plugins，可以对默认的应用和框架plugin进行覆盖\n    if (this.options.plugins) {\n      customPlugins = Object.assign({}, customPlugins, this.options.plugins);\n    }\n\n    this.allPlugins = {};\n    this.appPlugins = appPlugins;\n    this.customPlugins = customPlugins;\n    this.eggPlugins = eggPlugins;\n\n    &#x2F;&#x2F;按照顺序对plugin进行合并及覆盖\n    &#x2F;&#x2F;_extendPlugins在合并的过程中，对相同name的plugin中的属性进行覆盖，有一个特殊处理的地方，如果某个属性的值是空数组，那么不会覆盖前者\n    this._extendPlugins(this.allPlugins, eggPlugins);\n    this._extendPlugins(this.allPlugins, appPlugins);\n    this._extendPlugins(this.allPlugins, customPlugins);\n\n    const enabledPluginNames = []; &#x2F;&#x2F; enabled plugins that configured explicitly\n    const plugins = {};\n    const env = this.serverEnv;\n    for (const name in this.allPlugins) {\n      const plugin = this.allPlugins[name];\n      &#x2F;&#x2F;plugin的path可能是直接指定的，也有可能指定了一个package的name，然后从node_modules中查找\n      &#x2F;&#x2F;从node_modules中查找的顺序是：{APP_PATH}&#x2F;node_modules -&gt; {EGG_PATH}&#x2F;node_modules -&gt; $CWD&#x2F;node_modules\n      plugin.path = this.getPluginPath(plugin, this.options.baseDir);\n      &#x2F;&#x2F;这个函数会读取每个plugin.path路径下的package.json,获取plugin的version，并会使用package.json中的dependencies，optionalDependencies, env变量作覆盖\n      this.mergePluginConfig(plugin);\n      &#x2F;&#x2F; 有些plugin只有在某些环境（serverEnv）下才能使用，否则改成enable=false\n      if (env &amp;&amp; plugin.env.length &amp;&amp; !plugin.env.includes(env)) {\n        plugin.enable = false;\n        continue;\n      }\n      &#x2F;&#x2F;获取enable=true的所有pluginnName\n      plugins[name] = plugin;\n      if (plugin.enable) {\n        enabledPluginNames.push(name);\n      }\n    }\n\n    &#x2F;&#x2F;这个函数会检查插件的依赖关系，插件的依赖关系在dependencies中定义，最后返回所有需要的插件\n    &#x2F;&#x2F;如果enable=true的插件依赖的插件不在已有的插件中，或者插件的依赖关系存在循环引用，则会抛出异常\n    &#x2F;&#x2F;如果enable=true的依赖插件为enable=false，那么该被依赖的插件会被改为enable=true\n    this.orderPlugins = this.getOrderPlugins(plugins, enabledPluginNames, appPlugins);\n\n    &#x2F;&#x2F;最后我们以对象的方式将enable=true的插件挂载在this对象上\n    const enablePlugins = {};\n    for (const plugin of this.orderPlugins) {\n      enablePlugins[plugin.name] = plugin;\n    }\n    this.plugins = enablePlugins;\n}\n</code></pre><h5>loadConfig函数</h5>\n<p>配置信息的管理对于一个应用来说非常重要，我们需要对不同的部署环境的配置进行管理，Egg就是针对环境加载不同的配置文件，然后将配置挂载在app上，</p>\n<p>加载config的逻辑相对简单，就是按照顺序加载所有loadUnit目录下的config文件内容，进行合并，最后将config信息挂载在this对象上，整个加载函数请看下面源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; loadConfig函数分析\n\nloadConfig() {\n    this.configMeta = {};\n    const target = {};\n    &#x2F;&#x2F;这里之所以先加载app相关的config，是因为在加载plugin和framework的config时会使用到app的config\n    const appConfig = this._preloadAppConfig();\n    \n    &#x2F;&#x2F;config的加载顺序为：plugin config.default -&gt; framework config.default -&gt; app config.default -&gt; plugin config.{env} -&gt; framework config.{env} -&gt; app config.{env}\n    for (const filename of this.getTypeFiles(&#x27;config&#x27;)) {\n    &#x2F;&#x2F; getLoadUnits函数前面有介绍，获取loadUnit目录集合\n      for (const unit of this.getLoadUnits()) {\n        const isApp = unit.type === &#x27;app&#x27;;\n        &#x2F;&#x2F;如果是加载插件和框架下面的config，那么会将appConfig当作参数传入\n        &#x2F;&#x2F;这里appConfig已经加载了一遍了，又重复加载了，不知道处于什么原因，下面会有_loadConfig函数源码分析\n        const config = this._loadConfig(unit.path, filename, isApp ? undefined : appConfig, unit.type);\n        if (!config) {\n          continue;\n        }\n        &#x2F;&#x2F;config进行覆盖\n        extend(true, target, config);\n      }\n    }\n    this.config = target;\n}\n\n_loadConfig(dirpath, filename, extraInject, type) {\n    const isPlugin = type === &#x27;plugin&#x27;;\n    const isApp = type === &#x27;app&#x27;;\n\n    let filepath = this.resolveModule(path.join(dirpath, &#x27;config&#x27;, filename));\n    &#x2F;&#x2F;如果没有config.default文件，则用config.js文件替代，隐藏逻辑\n    if (filename === &#x27;config.default&#x27; &amp;&amp; !filepath) {\n      filepath = this.resolveModule(path.join(dirpath, &#x27;config&#x2F;config&#x27;));\n    }\n    &#x2F;&#x2F;loadFile函数我们在EggLoader中讲到过，如果config导出的是一个函数会先执行这个函数，将函数的返回结果导出，函数的参数也就是[this.appInfo extraInject]\n    const config = this.loadFile(filepath, this.appInfo, extraInject);\n    if (!config) return null;\n\n    &#x2F;&#x2F;框架使用哪些中间件也是在config里作配置的，后面关于loadMiddleware函数实现中有说明\n    &#x2F;&#x2F;coreMiddleware只能在框架里使用\n    if (isPlugin || isApp) {\n      assert(!config.coreMiddleware, &#x27;Can not define coreMiddleware in app or plugin&#x27;);\n    }\n    &#x2F;&#x2F;middleware只能在应用里定义\n    if (!isApp) {\n      assert(!config.middleware, &#x27;Can not define middleware in &#x27; + filepath);\n    }\n    &#x2F;&#x2F;这里是为了设置configMeta，表示每个配置项是从哪里来的\n    this[SET_CONFIG_META](config, filepath);\n    return config;\n  }\n</code></pre><h5>loadExtend相关函数</h5>\n<p>这里的loadExtend是一个笼统的概念，其实是针对koa中的app.response，app.respond，app.context以及app本身进行扩展，同样是根据所有loadUnits下的配置顺序进行加载</p>\n<p>下面看一下loadExtend这个函数的实现，一个通用的加载函数</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core -&gt; loadExtend函数实现\n\n&#x2F;&#x2F;name输入是&quot;response&quot;&#x2F;&quot;respond&quot;&#x2F;&quot;context&quot;&#x2F;&quot;app&quot;中的一个，proto是被扩展的对象\nloadExtend(name, proto) {\n    &#x2F;&#x2F;获取指定name所有loadUnits下的配置文件路径\n    const filepaths = this.getExtendFilePaths(name);\n    const isAddUnittest = &#x27;EGG_MOCK_SERVER_ENV&#x27; in process.env &amp;&amp; this.serverEnv !== &#x27;unittest&#x27;;\n    for (let i = 0, l = filepaths.length; i &lt; l; i++) {\n      const filepath = filepaths[i];\n      filepaths.push(filepath + &#96;.${this.serverEnv}&#96;);\n      if (isAddUnittest) filepaths.push(filepath + &#x27;.unittest&#x27;);\n    }\n\n    &#x2F;&#x2F;这里并没有对属性的直接覆盖，而是对原先的PropertyDescriptor的get和set进行合并\n    const mergeRecord = new Map();\n    for (let filepath of filepaths) {\n      filepath = this.resolveModule(filepath);\n      const ext = this.requireFile(filepath);\n\n      const properties = Object.getOwnPropertyNames(ext)\n        .concat(Object.getOwnPropertySymbols(ext));\n      for (const property of properties) {\n        let descriptor = Object.getOwnPropertyDescriptor(ext, property);\n        let originalDescriptor = Object.getOwnPropertyDescriptor(proto, property);\n        if (!originalDescriptor) {\n          const originalProto = originalPrototypes[name];\n          if (originalProto) {\n            originalDescriptor = Object.getOwnPropertyDescriptor(originalProto, property);\n          }\n        }\n        &#x2F;&#x2F;如果原始对象上已经存在相关属性的Descriptor，那么对其set和get方法进行合并\n        if (originalDescriptor) {\n          &#x2F;&#x2F; don&#x27;t override descriptor\n          descriptor = Object.assign({}, descriptor);\n          if (!descriptor.set &amp;&amp; originalDescriptor.set) {\n            descriptor.set = originalDescriptor.set;\n          }\n          if (!descriptor.get &amp;&amp; originalDescriptor.get) {\n            descriptor.get = originalDescriptor.get;\n          }\n        }\n        &#x2F;&#x2F;否则直接覆盖\n        Object.defineProperty(proto, property, descriptor);\n        mergeRecord.set(property, filepath);\n      }\n    }\n  }\n</code></pre><h5>loadService函数</h5>\n<h6>如何在egg框架中使用service</h6>\n<p>loadService函数的实现是所有load函数中最复杂的一个，我们不着急看源码，先看一下service在egg框架中如何使用</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; 如何在egg框架中使用service\n\n&#x2F;&#x2F;方式1：app&#x2F;service&#x2F;user1.js\n&#x2F;&#x2F;这个是最标准的做法，导出一个class，这个class继承了require(&#x27;egg&#x27;).Service，其实也就是我们上文提到的eggCore导出的BaseContextClass\n&#x2F;&#x2F;最终我们在业务逻辑中获取到的是这个class的一个实例，在load的时候是将app.context当作新建实例的参数\n&#x2F;&#x2F;在controller中调用方式：this.ctx.service.user1.find(1)\nconst Service = require(&#x27;egg&#x27;).Service;\nclass UserService extends Service {\n  async find(uid) {\n    &#x2F;&#x2F;此时我们可以通过this.ctx,this.app,this.config,this.service获取到有用的信息，尤其是this.ctx非常重要，每个请求对应一个ctx，我们可以查询到当前请求的所有信息\n    const user = await this.ctx.db.query(&#x27;select * from user where uid = ?&#x27;, uid);\n    return user;\n  }\n}\nmodule.exports = UserService;\n\n&#x2F;&#x2F;方式2：app&#x2F;service&#x2F;user2.js\n&#x2F;&#x2F;这个做法是我模拟了一个BaseContextClass，当然也就可以实现方法1的目的，但是不推荐\nclass UserService {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.app = ctx.app;\n    this.config = ctx.app.config;\n    this.service = ctx.service;\n  }\n  async find(uid) {\n    const user = await this.ctx.db.query(&#x27;select * from user where uid = ?&#x27;, uid);\n    return user;\n  }\n}\nmodule.exports = UserService;\n\n&#x2F;&#x2F;方式3：app&#x2F;service&#x2F;user3.js\n&#x2F;&#x2F;service中也可以export函数，在load的时候会主动调用这个函数，把appInfo参数传入，最终获取到的是函数返回结果\n&#x2F;&#x2F;在controller中调用方式：this.ctx.service.user3.getAppName(1)，这个时候在service中获取不到当前请求的上下文ctx\nmodule.exports = (appInfo) =&gt; {\n    return {\n        async getAppName(uid){\n            return appInfo.name;\n        }\n    }\n};\n\n&#x2F;&#x2F;方式4：app&#x2F;service&#x2F;user4.js\n&#x2F;&#x2F;service也可以直接export普通的原生对象，load的时候会将该普通对象返回，同样获取不到当前请求的上下文ctx\n&#x2F;&#x2F;在controller中调用方式：this.ctx.service.user4.getAppName(1)\nmodule.exports = {\n    async getAppName(uid){\n        return appInfo.name;\n    }\n};\n</code></pre><p>我们上面列举了service下的js文件的四种写法，都是从每次请求的上下文this.ctx获取到service对象，然后就可以使用到每个service文件导出的对象了，这里主要有两个地方需要注意：</p>\n<ol>\n<li>\n<p>为什么我们可以从每个请求的this.ctx上获取到service对象呢：</p>\n<p>看过koa源码的同学知道，this.ctx其实是从app.context继承而来，所以我们只要把service绑定到app.context上，那么当前请求的上下文ctx自然可以拿到service对象，eggLoader也是这样做的</p>\n</li>\n<li>\n<p>针对上述四种使用场景，具体导出实例是怎么处理的呢？</p>\n<ul>\n<li>如果导出的是一个类，EggLoader会主动以ctx对象去初始化这个实例并导出，所以我们就可以直接在该类中使用this.ctx获取当前请求的上下文了</li>\n<li>如果导出的是一个函数，那么EggLoader会以app作为参数运行这个函数并将结果导出</li>\n<li>如果是一个普通的对象，直接导出</li>\n</ul>\n</li>\n</ol>\n<h6>FileLoader类的实现分析</h6>\n<p>在实现loadService函数时，有一个基础类就是FileLoader，它同时也是loadMiddleware，loadController实现的基础，这个类提供一个load函数根据目录结构和文件内容进行解析，返回一个target对象，我们可以根据文件名以及子文件名以及函数名称获取到service里导出的内容，target结构类似这样：</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;file1&quot;: {\n        &quot;file11&quot;: {\n            &quot;function1&quot;: a =&gt; a\n        }\n    },\n    &quot;file2&quot;: {\n        &quot;function2&quot;: a =&gt; a\n    }\n}\n\n\n</code></pre><p>下面我们先看一下fileLoader这个类的实现</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; FileLoader实现\n\nclass FileLoader {\n  constructor(options) {\n    &#x2F;*options里几个重要参数的含义:\n    1.directory: 需要加载文件的所有目录\n    2.target: 最终加载成功后的目标对象\n    3.initializer：一个初始化函数，对文件导出内容进行初始化，这个在loadController实现时会用到\n    4.inject：如果某个文件的导出对象是一个函数，那么将该值传入函数并执行导出，一般都是this.app\n    *&#x2F;\n    this.options = Object.assign({}, defaults, options);\n  }\n  load() {\n    &#x2F;&#x2F;解析directory下的文件，下面有parse函数的部分实现\n    const items = this.parse();\n    const target = this.options.target;\n    &#x2F;&#x2F;item1 = { properties: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], exports1 },item2 = { properties: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;], exports2 }\n    &#x2F;&#x2F; =&gt; target = {a: {b: {c: exports1, d: exports2}}}\n    &#x2F;&#x2F;根据文件路径名称递归生成一个大的对象target，我们通过target.file1.file2就可以获取到对应的导出内容\n    for (const item of items) {\n      item.properties.reduce((target, property, index) =&gt; {\n        let obj;\n        const properties = item.properties.slice(0, index + 1).join(&#x27;.&#x27;);\n        if (index === item.properties.length - 1) {\n          obj = item.exports;\n          if (obj &amp;&amp; !is.primitive(obj)) {\n            &#x2F;&#x2F;这步骤很重要，确定这个target是不是一个exports，有可能只是一个路径而已\n            obj[FULLPATH] = item.fullpath;\n            obj[EXPORTS] = true;\n          }\n        } else {\n          obj = target[property] || {};\n        }\n        target[property] = obj;\n        return obj;\n      }, target);\n    }\n    return target;\n  }\n  \n  &#x2F;&#x2F;最终生成[{ properties: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], exports，fullpath}]形式，properties文件路径名称的数组，exports是导出对象，fullpath是文件的绝对路径\n  parse() {\n    &#x2F;&#x2F;文件目录转换为数组\n    let directories = this.options.directory;\n    if (!Array.isArray(directories)) {\n      directories = [ directories ];\n    }\n    &#x2F;&#x2F;遍历所有文件路径\n    const items = [];\n    for (const directory of directories) {\n      &#x2F;&#x2F;每个文件目录下面可能还会有子文件夹，所以globby.sync函数是获取所有文件包括子文件下的文件的路径\n      const filepaths = globby.sync(files, { cwd: directory });\n      for (const filepath of filepaths) {\n        const fullpath = path.join(directory, filepath);\n        if (!fs.statSync(fullpath).isFile()) continue;\n        &#x2F;&#x2F;获取文件路径上的以&quot;&#x2F;&quot;分割的所有文件名，foo&#x2F;bar.js =&gt; [ &#x27;foo&#x27;, &#x27;bar&#x27; ]，这个函数会对propertie同一格式，默认为驼峰\n        const properties = getProperties(filepath, this.options);\n        &#x2F;&#x2F;app&#x2F;service&#x2F;foo&#x2F;bar.js =&gt; service.foo.bar\n        const pathName = directory.split(&#x2F;[&#x2F;\\\\]&#x2F;).slice(-1) + &#x27;.&#x27; + properties.join(&#x27;.&#x27;);\n        &#x2F;&#x2F;getExports函数获取文件内容，并将结果做一些处理，看下面实现\n        const exports = getExports(fullpath, this.options, pathName);\n        &#x2F;&#x2F;如果导出的是class，会设置一些属性，这个属性下文中对于class的特殊处理地方会用到\n        if (is.class(exports)) {\n          exports.prototype.pathName = pathName;\n          exports.prototype.fullPath = fullpath;\n        }\n        items.push({ fullpath, properties, exports });\n      }\n    }\n    return items;\n  }\n}\n\n&#x2F;&#x2F;根据指定路径获取导出对象并作预处理\nfunction getExports(fullpath, { initializer, call, inject }, pathName) {\n  let exports = utils.loadFile(fullpath);\n  &#x2F;&#x2F;用initializer函数对exports结果做预处理\n  if (initializer) {\n    exports = initializer(exports, { path: fullpath, pathName });\n  }\n  &#x2F;&#x2F;如果exports是class，generatorFunction，asyncFunction则直接返回    \n  if (is.class(exports) || is.generatorFunction(exports) || is.asyncFunction(exports)) {\n    return exports;\n  }\n  &#x2F;&#x2F;如果导出的是一个普通函数，并且设置了call=true，默认是true，会将inject传入并调用该函数，上文中提到过好几次，就是在这里实现的\n  if (call &amp;&amp; is.function(exports)) {\n    exports = exports(inject);\n    if (exports != null) {\n      return exports;\n    }\n  }\n  &#x2F;&#x2F;其它情况直接返回\n  return exports;\n}\n\n</code></pre><h6>ContextLoader类的实现分析</h6>\n<p>上文中说道loadService函数其实最终把service对象挂载在了app.context上，所以为此提供了ContextLoader这个类，继承了FileLoader类，用于将FileLoader解析出来的target挂载在app.context上，下面是其实现：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core -&gt; ContextLoader类的源码实现\n\nclass ContextLoader extends FileLoader {\n  constructor(options) {\n    const target = options.target = {};\n    super(options);\n    &#x2F;&#x2F;FileLoader已经讲过inject就是app\n    const app = this.options.inject;\n    &#x2F;&#x2F;property就是要挂载的属性，比如&quot;service&quot;\n    const property = options.property;\n    &#x2F;&#x2F;将service属性挂载在app.context上\n    Object.defineProperty(app.context, property, {\n      get() {\n        &#x2F;&#x2F;做缓存，由于不同的请求ctx不一样，这里是针对同一个请求的内容进行缓存\n        if (!this[CLASSLOADER]) {\n          this[CLASSLOADER] = new Map();\n        }\n        const classLoader = this[CLASSLOADER];\n        &#x2F;&#x2F;获取导出实例，这里就是上文用例中获取this.ctx.service.file1.fun1的实现，这里的实例就是this.ctx.service,实现逻辑请看下面的getInstance的实现\n        let instance = classLoader.get(property);\n        if (!instance) {\n          &#x2F;&#x2F;这里传入的this就是为了初始化require(&#x27;egg&#x27;).Service实例时当作参数传入\n          &#x2F;&#x2F;this会根据调用者的不同而改变，比如是app.context的实例调用那么就是app.context，如果是app.context子类的实例调用，那么就是其子类的实例\n          &#x2F;&#x2F;就是因为这个this，我们service里继承require(&#x27;egg&#x27;).Service，才可以通过this.ctx获取到当前请求的上下文\n          instance = getInstance(target, this);\n          classLoader.set(property, instance);\n        }\n        return instance;\n      },\n    });\n  }\n}\n\n&#x2F;&#x2F;values是FileLoader&#x2F;load函数生成target对象\nfunction getInstance(values, ctx) {\n  &#x2F;&#x2F;上文FileLoader里实现中我们讲过，target对象是一个由路径和exports组装成的一个大对象，这里Class是为了确定其是不是一个exports，有可能是一个路径名\n  const Class = values[EXPORTS] ? values : null;\n  let instance;\n  if (Class) {\n    if (is.class(Class)) {\n        &#x2F;&#x2F;这一步很重要，如果是类，就用ctx进行初始化获取实例\n      instance = new Class(ctx);\n    } else {\n      &#x2F;&#x2F;普通对象直接导出，这里要注意的是如果是exports函数，在FileLoader实现中已经将其执行并转换为了对象\n      &#x2F;&#x2F;function和class分别在子类和父类的处理的原因是，function的处理逻辑loadMiddleware,loadService,loadController公用，而class的处理逻辑loadService使用\n      instance = Class;\n    }\n  } else if (is.primitive(values)) {\n    &#x2F;&#x2F;原生类型直接导出\n    instance = values;\n  } else {\n    &#x2F;&#x2F;如果目前的target部分是一个路径，那么会新建一个ClassLoader实例，这个ClassLoader中又会递归的调用getInstance\n    &#x2F;&#x2F;这里之所以新建一个类，一是为了做缓存，二是为了在每个节点获取到的都是一个类的实例\n    instance = new ClassLoader({ ctx, properties: values });\n  }\n  return instance;\n}\n</code></pre><h6>loadService的实现</h6>\n<p>有了ContextLoader类，那实现loadService函数就非常容易了，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core -&gt; loadService函数实现源码\n&#x2F;&#x2F;loadService函数调用loadToContext函数\nloadService(opt) {\n    opt = Object.assign({\n      call: true,\n      caseStyle: &#x27;lower&#x27;,\n      fieldClass: &#x27;serviceClasses&#x27;,\n      directory: this.getLoadUnits().map(unit =&gt; path.join(unit.path, &#x27;app&#x2F;service&#x27;)), &#x2F;&#x2F;所有加载单元目录下的service\n    }, opt);\n    const servicePaths = opt.directory;\n    this.loadToContext(servicePaths, &#x27;service&#x27;, opt);\n}\n&#x2F;&#x2F;loadToContext函数直接新建ContextLoader实例，调用load函数实现加载\nloadToContext(directory, property, opt) {\n    opt = Object.assign({}, {\n      directory,\n      property,\n      inject: this.app,\n    }, opt);\n    new ContextLoader(opt).load();\n}\n</code></pre><h5>loadMiddleware函数</h5>\n<p>中间件是koa框架中很重要的一个环节，通过app.use引入中间件，使用洋葱圈模型，所以中间件加载的顺序很重要。</p>\n<ul>\n<li>如果在上文中的config中配置的中间件，系统会自动用app.use函数使用该中间件</li>\n<li>所有的中间件我们都可以在app.middleware中通过中间件name获取到，便于在业务中动态使用</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core -&gt; loadMiddleware函数实现源码\n\nloadMiddleware(opt) {\n    const app = this.app;\n    &#x2F;&#x2F; load middleware to app.middleware\n    opt = Object.assign({\n      call: false,   &#x2F;&#x2F;call=false表示如果中间件导出是函数，不会主动调用函数做转换\n      override: true,\n      caseStyle: &#x27;lower&#x27;,\n      directory: this.getLoadUnits().map(unit =&gt; join(unit.path, &#x27;app&#x2F;middleware&#x27;)) &#x2F;&#x2F;所有加载单元目录下的middleware\n    }, opt);\n    const middlewarePaths = opt.directory;\n    &#x2F;&#x2F;将所有中间件middlewares挂载在app上，这个函数在loadController实现中也用到了，看下文的实现\n    this.loadToApp(middlewarePaths, &#x27;middlewares&#x27;, opt);\n    &#x2F;&#x2F;将app.middlewares中的每个中间件重新绑定在app.middleware上，每个中间件的属性不可配置，不可枚举\n    for (const name in app.middlewares) {\n      Object.defineProperty(app.middleware, name, {\n        get() {\n          return app.middlewares[name];\n        },\n        enumerable: false,\n        configurable: false,\n      });\n    }\n    &#x2F;&#x2F;只有在config中配置了appMiddleware和coreMiddleware才会直接在app.use中使用，其它中间件只是挂载在app上，开发人员可以动态使用\n    const middlewareNames = this.config.coreMiddleware.concat(this.config.appMiddleware);\n    const middlewaresMap = new Map();\n    for (const name of middlewareNames) {\n      &#x2F;&#x2F;如果config中定义middleware在app.middlewares中找不到或者重复定义，都会报错\n      if (!app.middlewares[name]) {\n        throw new TypeError(&#96;Middleware ${name} not found&#96;);\n      }\n      if (middlewaresMap.has(name)) {\n        throw new TypeError(&#96;Middleware ${name} redefined&#96;);\n      }\n      middlewaresMap.set(name, true);\n      const options = this.config[name] || {};\n      let mw = app.middlewares[name];\n      &#x2F;&#x2F;中间件的文件定义必须exports一个普通function，并且接受两个参数：\n      &#x2F;&#x2F;options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来, app: 当前应用 Application 的实例\n      &#x2F;&#x2F;执行exports的函数，生成最终要的中间件\n      mw = mw(options, app);\n      mw._name = name;\n      &#x2F;&#x2F;包装中间件，最终转换成async function(ctx, next)形式\n      mw = wrapMiddleware(mw, options);\n      if (mw) {\n        app.use(mw);\n        this.options.logger.info(&#x27;[egg:loader] Use middleware: %s&#x27;, name);\n      } else {\n        this.options.logger.info(&#x27;[egg:loader] Disable middleware: %s&#x27;, name);\n      }\n    }\n}\n\n&#x2F;&#x2F;通过FileLoader实例加载指定属性的所有文件并导出，然后将该属性挂载在app上\nloadToApp(directory, property, opt) {\n    const target = this.app[property] = {};\n    opt = Object.assign({}, {\n      directory,\n      target,\n      inject: this.app,\n    }, opt);\n    new FileLoader(opt).load();\n}\n</code></pre><h5>loadController函数</h5>\n<p>controller中生成的函数最终还是在router.js中当作一个中间件使用，所以我们需要将controller中内容转换为中间件形式async function(ctx, next)，其中initializer这个函数就是用来针对不同的情况将controller中的内容转换为中间件的，下面是loadController的实现逻辑：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; loadController函数实现源码\n\nloadController(opt) {\n    opt = Object.assign({\n      caseStyle: &#x27;lower&#x27;,\n      directory: path.join(this.options.baseDir, &#x27;app&#x2F;controller&#x27;),\n      &#x2F;&#x2F;这个配置，上文有提到，是为了对导出对象做预处理的函数\n      initializer: (obj, opt) =&gt; {\n        &#x2F;&#x2F;如果是普通函数，依然直接调用它生成新的对象\n        if (is.function(obj) &amp;&amp; !is.generatorFunction(obj) &amp;&amp; !is.class(obj) &amp;&amp; !is.asyncFunction(obj)) {\n          obj = obj(this.app);\n        }\n        if (is.class(obj)) {\n          obj.prototype.pathName = opt.pathName;\n          obj.prototype.fullPath = opt.path;\n          &#x2F;&#x2F;如果是一个class，class中的函数转换成async function(ctx, next)中间件形式，并用ctx去初始化该class，所以在controller里我们也可以使用this.ctx.xxx形式\n          return wrapClass(obj);\n        }\n        if (is.object(obj)) {\n          &#x2F;&#x2F;如果是一个Object，会递归的将该Object中每个属性对应的函数转换成async function(ctx, next)中间件形式形式\n          return wrapObject(obj, opt.path);\n        }\n        &#x2F;&#x2F; support generatorFunction for forward compatbility\n        if (is.generatorFunction(obj) || is.asyncFunction(obj)) {\n          return wrapObject({ &#x27;module.exports&#x27;: obj }, opt.path)[&#x27;module.exports&#x27;];\n        }\n        return obj;\n      },\n    }, opt);\n    &#x2F;&#x2F;loadController函数同样是通过loadToApp函数将其导出对象挂载在app下，controller里的内容在loadRouter时会将其载入\n    const controllerBase = opt.directory;\n    this.loadToApp(controllerBase, &#x27;controller&#x27;, opt);\n  },\n</code></pre><h5>loadRouter函数</h5>\n<p>loadRouter函数特别简单，只是require加载一下app/router目录下的文件而已，而所有的事情都交给了EggCore类上的router属性去实现</p>\n<p>而router又是Router类的实例，Router类是基于koa-router实现的</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; loadRouter函数源码实现\n\nloadRouter() {\n    this.loadFile(this.resolveModule(path.join(this.options.baseDir, &#x27;app&#x2F;router&#x27;)));\n}\n\n&#x2F;&#x2F;设置router属性的get方法\nget router() {\n    &#x2F;&#x2F;缓存设置\n    if (this[ROUTER]) {\n      return this[ROUTER];\n    }\n    &#x2F;&#x2F;新建Router实例，其中Router类是继承koa-router实现的\n    const router = this[ROUTER] = new Router({ sensitive: true }, this);\n    &#x2F;&#x2F;在启动前将router中间件载入引用\n    this.beforeStart(() =&gt; {\n      this.use(router.middleware());\n    });\n    return router;\n}\n  \n&#x2F;&#x2F;将router上所有的method函数代理到EggCore上，这样我们就可以通过app.get(&#x27;&#x2F;async&#x27;, ...asyncMiddlewares, &#x27;subController.subHome.async1&#x27;)的方式配置路由\nutils.methods.concat([ &#x27;all&#x27;, &#x27;resources&#x27;, &#x27;register&#x27;, &#x27;redirect&#x27; ]).forEach(method =&gt; {\n  EggCore.prototype[method] = function(...args) {\n    this.router[method](...args);\n    return this;\n  };\n})  \n</code></pre><p>Router类继承了KoaRouter类，并对其的method相关函数做了扩展，解析controller的写法，同时提供了resources方法，为了兼容restAPI的方式</p>\n<p>关于restAPI的使用方式和实现源码我们这里就不介绍了，可以看官方文档，有具体的格式要求，下面看一下Router类的部分实现逻辑：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;egg-core源码 -&gt; Router类实现源码\n\nclass Router extends KoaRouter {\n  constructor(opts, app) {\n    super(opts);\n    this.app = app;\n    &#x2F;&#x2F;对method方法进行扩展\n    this.patchRouterMethod();\n  }\n  \n  patchRouterMethod() {\n    &#x2F;&#x2F;为了支持generator函数类型，以及获取controller类中导出的中间件\n    methods.concat([ &#x27;all&#x27; ]).forEach(method =&gt; {\n      this[method] = (...args) =&gt; {\n        &#x2F;&#x2F;spliteAndResolveRouterParams主要是为了拆分router.js中的路由规则，将其拆分成普通中间件和controller生成的中间件部分，请看下文源码\n        const splited = spliteAndResolveRouterParams({ args, app: this.app });\n        args = splited.prefix.concat(splited.middlewares);\n        return super[method](...args);\n      };\n    });\n  }\n  \n  &#x2F;&#x2F;返回router里每个路由规则的前缀和中间件部分\n  function spliteAndResolveRouterParams({ args, app }) {\n    let prefix;\n    let middlewares;\n    if (args.length &gt;= 3 &amp;&amp; (is.string(args[1]) || is.regExp(args[1]))) {\n        &#x2F;&#x2F; app.get(name, url, [...middleware], controller)的形式\n        prefix = args.slice(0, 2);\n        middlewares = args.slice(2);\n      } else {\n        &#x2F;&#x2F; app.get(url, [...middleware], controller)的形式\n        prefix = args.slice(0, 1);\n        middlewares = args.slice(1);\n      }\n      &#x2F;&#x2F;controller部分肯定是最后一个\n      const controller = middlewares.pop();\n      &#x2F;&#x2F;resolveController函数主要是为了处理router.js中关于controller的两种写法：\n      &#x2F;&#x2F;写法1：app.get(&#x27;&#x2F;async&#x27;, ...asyncMiddlewares, &#x27;subController.subHome.async1&#x27;)\n      &#x2F;&#x2F;写法2：app.get(&#x27;&#x2F;async&#x27;, ...asyncMiddlewares, subController.subHome.async1)\n      &#x2F;&#x2F;最终从app.controller上获取到真正的controller中间件，resolveController具体函数实现就不介绍了\n      middlewares.push(resolveController(controller, app));\n      return { prefix, middlewares };\n  }\n</code></pre><h3>总结</h3>\n<p>以上便是我对EggCore的大部分源码的实现的学习总结，其中关于源码中一些debug代码以及timing运行时间记录的代码都删掉了，关于app的生命周期管理的那部分代码和loadUnits加载逻辑关系不大，所以没有讲到。EggCore的核心在于EggLoader，也就是plugin，config, extend, service, middleware, controller, router的加载函数，而这几个内容加载必须按照顺序进行加载，存在依赖关系，比如：</p>\n<ul>\n<li>加载middleware时会用到config关于应用中间件的配置</li>\n<li>加载router时会用到关于controller的配置</li>\n<li>而config，extend，service，middleware，controller的加载都必须依赖于plugin，通过plugin配置获取插件目录</li>\n<li>service，middleware，controller，router的加载又必须依赖于extend（对app进行扩展），因为如果exports是函数的情况下，会将app作为参数执行函数</li>\n</ul>\n<p>EggCore是一个基础框架，其最重要的是需要遵循一定的约束和约定，可以保证一致的代码风格，而且提供了插件和框架机制，能使相同的业务逻辑实现复用，后面看有时间再写一下egg框架的源码</p>\n<h3>参考文献</h3>\n<ul>\n<li><a href=\"https://blog.csdn.net/zdplife/article/details/83147615\">egg源码学习之egg-core</a></li>\n<li><a href=\"https://github.com/eggjs/egg-core\">agg-core源码</a></li>\n<li><a href=\"https://github.com/eggjs/egg\">egg源码</a></li>\n<li><a href=\"https://eggjs.org/zh-cn/basics/structure.html\">egg官方文档</a></li>\n</ul>\n</div>",
            "title": "egg源码分析之egg-core",
            "last_reply_at": "2018-10-19T11:08:28.994Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 312,
            "create_at": "2018-10-19T01:27:46.036Z",
            "author": {
                "loginname": "ZhangDianPeng",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18463189?v=4&s=120"
            }
        },
        {
            "id": "5bc9ba4b37a6965f590523d4",
            "author_id": "5ad1f9f3464b1bfa6b425155",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请求测试环境的api，是需要登陆测试环境的，但是我希望用localhost本地访问的时候，用node做个代理去访问测试环境的api。这个时候解决方法1\n我会在设置 header 的时候手动的将 测试环境的 cookie 填进去。\n但是总觉得 这样不靠谱，有没有其他方法？</p>\n</div>",
            "title": "如何用request拿到测试环境需要身份验证的数据？",
            "last_reply_at": "2018-10-19T11:04:43.056Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 75,
            "create_at": "2018-10-19T11:04:43.056Z",
            "author": {
                "loginname": "MEDIOCAL",
                "avatar_url": "https://avatars1.githubusercontent.com/u/22210932?v=4&s=120"
            }
        },
        {
            "id": "5bc9aabe9545eaf107b9ccce",
            "author_id": "5b74f778a210553a0cde2979",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>求教关于proxyTable跨域的问题！！！！急</p>\n</div>",
            "title": "求教关于proxyTable跨域的问题！！！！急",
            "last_reply_at": "2018-10-19T09:58:22.692Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 87,
            "create_at": "2018-10-19T09:58:22.692Z",
            "author": {
                "loginname": "zhuhaifeng1251pm",
                "avatar_url": "https://avatars1.githubusercontent.com/u/41354007?v=4&s=120"
            }
        },
        {
            "id": "5bc7f26e37a6965f59052333",
            "author_id": "5afad54902591040485bae97",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>并行执行Promise.all()\n那么串行怎么写？\n直接上代码:</p>\n<pre class=\"prettyprint language-\"><code>const  promisesFuncs = [promise1,promise2,...];\nconst computeSinglePromise = function (promisesFuncs, initParams) {\n    let resultsArray = [];\n    return promiseFuncs.reduce((promise, fn, index) =&gt; {\n         console.log(&quot;reduce start&quot;, index);\n         return promise.then((result) =&gt; {\n             resultsArray.push(result);\n             return fn(result);\n         });\n     }, Promise.resolve(initParams))\n         .then(() =&gt; {\n            return resultsArray;\n        });\n };\n</code></pre></div>",
            "title": "es6 Promise 串行执行",
            "last_reply_at": "2018-10-19T09:33:40.388Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 760,
            "create_at": "2018-10-18T02:39:42.332Z",
            "author": {
                "loginname": "lwcbest",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18455510?v=4&s=120"
            }
        },
        {
            "id": "5b3748c457137f22415c5143",
            "author_id": "5b37469f57137f22415c5140",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>当你用了Koa以后，你肯定不会再用express，因为Koa太优秀了!</p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\"></a><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p>Nodejs Koa交流群：319732955   想和大神交流的加下群</p>\n</div>",
            "title": "2018 Nodejs+Koa2入门实战视频教程【共41集】-欢迎拍砖免费分享【网盘直接下载】",
            "last_reply_at": "2018-10-19T09:14:47.943Z",
            "good": false,
            "top": false,
            "reply_count": 52,
            "visit_count": 8598,
            "create_at": "2018-06-30T09:09:24.209Z",
            "author": {
                "loginname": "koa666",
                "avatar_url": "https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"
            }
        },
        {
            "id": "5bc82b4815e4fd1923f4904a",
            "author_id": "58db8e8503d476b42d34c885",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>在开发vue项目，开发环境中，我在终端执行了npm run dev命令，这个时候如果我再编辑vue文件，编辑文件过程中出现了异常或者语法错误的时候，就会出现一个报错提示，如下图所示：\n<img src=\"//static.cnodejs.org/FnT5q1qV0ZL8hfeH1UxVAwpNeNMl\" alt=\"1.jpg\">\n这个报错提示是在哪里设置的，再就是我想改变这个提示的弹出机制，怎么该，或者直接关闭掉这个提示，怎么关闭？\n不知道大家都是怎么解决的。</p>\n</div>",
            "title": "vue中的报错提示怎么关闭",
            "last_reply_at": "2018-10-19T08:49:05.681Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 532,
            "create_at": "2018-10-18T06:42:16.543Z",
            "author": {
                "loginname": "suchcl",
                "avatar_url": "https://avatars1.githubusercontent.com/u/6346513?v=3&s=120"
            }
        },
        {
            "id": "5bc98ec89545eaf107b9ccb9",
            "author_id": "56fdcb26c5f5b4a959e91751",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>如题，自己开发了个博客收藏的功能，现在欢迎大家把自己的博客加入，增加自己的博客曝光度，现在加入，免审核</p>\n<p>地址如下： <a href=\"https://www.geekjc.com\">https://www.geekjc.com</a></p>\n</div>",
            "title": "开发了个博客收藏的功能",
            "last_reply_at": "2018-10-19T08:16:24.331Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 107,
            "create_at": "2018-10-19T07:59:04.178Z",
            "author": {
                "loginname": "cllgeek",
                "avatar_url": "https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"
            }
        },
        {
            "id": "5bc95f1d15e4fd1923f490c3",
            "author_id": "5b67b716b71aedfe4c12678a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/cnodejs/egg-cnode\">https://github.com/cnodejs/egg-cnode</a></p>\n<p>egg-cnode已经搭建起来了   github 登录的回调地址如何配置？ 如下图</p>\n<p>老铁们有用过的吗</p>\n<p><img src=\"//static.cnodejs.org/FsSDVtSGTGyxBF8RqNkDlbRGufDQ\" alt=\"222.png\"></p>\n</div>",
            "title": "egg-cnode  github 登录的回调地址如何配置",
            "last_reply_at": "2018-10-19T08:05:37.934Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 96,
            "create_at": "2018-10-19T04:35:41.208Z",
            "author": {
                "loginname": "openkeyer",
                "avatar_url": "https://avatars2.githubusercontent.com/u/42114783?v=4&s=120"
            }
        },
        {
            "id": "5bc98c459545eaf107b9ccb5",
            "author_id": "564582ec5e7412b625b8bf16",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我使用request 模块模拟 http请求，爬取内容。但是程序经常会报下面的错。请问是什么错，如何解决。</p>\n<p>at _errnoException (util.js:992:11)\nat TCP.onread (net.js:618:25) code: ‘ECONNRESET’, errno: ‘ECONNRESET’, syscall: ‘read’ },</p>\n</div>",
            "title": "http请求发生的问题，请看正文。",
            "last_reply_at": "2018-10-19T07:52:14.479Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 80,
            "create_at": "2018-10-19T07:48:21.071Z",
            "author": {
                "loginname": "RajanZhan",
                "avatar_url": "https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"
            }
        },
        {
            "id": "5bc0c68915e4fd1923f48e8d",
            "author_id": "5a95875171327bb413bbff1b",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请教各位，大概的情况是这样的：\n<img src=\"https://img-blog.csdn.net/20181013000255483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dyZWVrTXJ6eko=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"//static.cnodejs.org/FkcDpeHFngJwg7tnhkDcxYhkPeTj\" alt=\"image.png\"></p>\n<p>这种情况怎么办？ 比较干扰视线。这个问题也不知道在百度和google 搜，搜出来全是开发 chrome 插件的内容。</p>\n</div>",
            "title": "chrome 调试时的 network 中有太多插件加载的js文件干扰怎么办？",
            "last_reply_at": "2018-10-19T07:22:44.704Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 702,
            "create_at": "2018-10-12T16:06:33.498Z",
            "author": {
                "loginname": "ZhijianZhang",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11473889?v=4&s=120"
            }
        },
        {
            "id": "5bc963ce15e4fd1923f490c6",
            "author_id": "5b52d32ffb9e84ec69cc1ca6",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/cnodejs/egg-cnode\">https://github.com/cnodejs/egg-cnode</a></p>\n<p>egg-cnode  默认的管理员是什么，如何配置有人知道吗</p>\n<p>环境已经搭建起来了，但是不知道如何管理别人发的帖子</p>\n</div>",
            "title": "egg-cnode  默认的管理员如何配置 大家用过吗",
            "last_reply_at": "2018-10-19T05:14:36.491Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 103,
            "create_at": "2018-10-19T04:55:42.899Z",
            "author": {
                "loginname": "vueper",
                "avatar_url": "https://avatars0.githubusercontent.com/u/41501656?v=4&s=120"
            }
        },
        {
            "id": "5bc8c33515e4fd1923f4909d",
            "author_id": "5a8eb2ce653c43b914684ee0",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h3>egg-artisan: 提供一个基于egg的命令行运行模式。</h3>\n<blockquote>\n<p>github: <a href=\"https://github.com/zzzs/egg-artisan\">https://github.com/zzzs/egg-artisan</a></p>\n</blockquote>\n<h3>前言</h3>\n<p>目前 egg 是没有基于开发业务功能的命令行运行模式的，比如我想在命令行执行个命令来处理一些业务相关的事，像数据库处理，缓存操作，文件操作等。当然<code>egg-bin</code>和<code>egg-scripts</code>也是命令行模式，但它们主要是项目维护，集成等作用，不是基于开发功能的。在 GitHub 找了好久没找到，于是就有个实现该想法的念头。</p>\n<h3>简介</h3>\n<p>egg-artisan 是基于 <a href=\"https://github.com/node-modules/common-bin\">common-bin</a> 的，为什么是 common-bin ？只能说命令行包这块自己也就对 common-bin 比较了解（如果有更好或更适合的欢迎提出），但功能上已经足够用了。<code>egg-artisan</code>在<code>run()</code>方法里注入了<code>this.ctx</code>,于是命令行也就有了操作 egg 项目内服务的能力，即能处理项目内业务相关的事。使用上，我们可以通过执行 <code>npm run artisan xxx</code> 来处理一些事。额外，也提供了<code>app.runArtisan(command, argvs)</code>方法使得能够在程序内也能调用。</p>\n<p>过程中学习到了一些内容：</p>\n<ul>\n<li><a href=\"https://github.com/node-modules/common-bin\">common-bin</a>, <a href=\"https://github.com/yargs/yargs\">yargs</a> 的学习</li>\n<li>egg 的启动流程</li>\n<li>egg-schedule, egg-mock 的学习</li>\n</ul>\n<h3>以下是具体README，尝试了把纯英文，有疑问或建议欢迎指出，谢谢！</h3>\n<h3>Install</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm i egg-artisan --save\n</code></pre><h3>Mount</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; {app_root}&#x2F;config&#x2F;plugin.js\nexports.artisan = {\n  enable: true,\n  package: &#x27;egg-artisan&#x27;,\n};\n</code></pre><h3>Features</h3>\n<blockquote>\n<p><code>egg-artisan</code> provides a cli running mode for egg. In the root directory, you can do something by executing commands like <code>npm run artisan xxx</code>, such as operating file, manipulating database scripts, updating cache scripts, etc.</p>\n</blockquote>\n<p><code>egg-artisan</code> based on <a href=\"https://github.com/node-modules/common-bin\">common-bin</a>(based on <a href=\"https://github.com/yargs/yargs\">yargs</a>), to provide more convenient usage, as detailed below.</p>\n<h3>Usage</h3>\n<p><code>egg-artisan</code> requires cli file to be stored in <code>app/artisan</code>, as shown below, <code>test.js</code>, <code>clone.js</code>.</p>\n<pre class=\"prettyprint\"><code>    egg-project\n    ├── app\n    │   ├── artisan\n    │   |   ├── test.js\n    │   |   └── clone.js\n    │   ├── controller\n    |   ├── router.js\n    |   | ...\n    ├── package.json\n    ├── config\n    ├── test\n    ├── app.js (可选)\n    ├── ...\n\n</code></pre><h4>How to write command</h4>\n<p>Let’s take test.js as an example, for the file operation.</p>\n<p>As you can see, the usage of the command is the same as that of <code>common-bin</code>, because <code>egg-artisan</code> extends <code>common-bin</code>. In addition, <code>egg-artisan</code> injected <strong><code>ths.ctx</code></strong> into the run method, so you can get anonymous context with <strong><code>ths.ctx</code></strong>.</p>\n<p>You can see <a href=\"https://github.com/node-modules/common-bin\">common-bin</a>, <a href=\"http://yargs.js.org/docs\">http://yargs.js.org/docs</a> for more detail.</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; {app_root}&#x2F;app&#x2F;artisan&#x2F;test.js\n\n&#x27;use strict&#x27;;\n\nconst Command = require(&#x27;egg-artisan&#x27;);\n\nclass TestCommand extends Command {\n  constructor(rawArgv) {\n    super(rawArgv);\n    this.yargs.usage(&#x27;test command&#x27;);\n\n    this.yargs.options({\n      a: {\n        type: &#x27;string&#x27;,\n        description: &#x27;test argv: a description&#x27;,\n      },\n    });\n  }\n\n  async run({ argv }) {\n    const aa = argv.a || &#x27;&#x27;;\n    const bb = argv.b || &#x27;&#x27;;\n    const cc = argv._.join(&#x27;,&#x27;);\n    await this.ctx.service.file.write(&#96;argv: ${aa}${bb}${cc}&#96;);\n    const con = await this.ctx.service.file.read();\n    console.log(&#x27;argv&#x27;, argv);\n    return con;\n  }\n\n  get description() {\n    return &#x27;test description&#x27;;\n  }\n}\n\nmodule.exports = TestCommand;\n</code></pre><h4>Add <code>egg-artisan</code> to package.json scripts:</h4>\n<pre class=\"prettyprint language-js\"><code>{\n  &quot;scripts&quot;: {\n    &quot;artisan&quot;: &quot;egg-artisan&quot;\n  }\n}\n</code></pre><h4>Run the test command</h4>\n<ul>\n<li>Show help, the following image has 2 custom commands: <code>test.js</code>, <code>clone.js</code>.</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>$ npm run artisan\n&#x2F;&#x2F; The following is the same\n&#x2F;&#x2F; npm run artisan -- -h\n&#x2F;&#x2F; npm run artisan -- help\n</code></pre><blockquote>\n<p>Why use <code>--</code> ? you can see <a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a>.</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FgYWP9MpTZXXG0nuJC0FhrW4k871\" alt=\"1.png\"></p>\n<ul>\n<li>Show <code>test.js</code> command help</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>$ npm run artisan -- test -h\n&#x2F;&#x2F; The following is the same\n&#x2F;&#x2F; npm run artisan -- test help\n</code></pre><p><img src=\"//static.cnodejs.org/FkM2u-j5t1HSuAGSi6FhChuqgpPv\" alt=\"2.png\"></p>\n<ul>\n<li>Run <code>test.js</code> command</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>$ npm run artisan -- test -x=1 --type=2 a b\n\n&#x2F;&#x2F; The following is the same\n&#x2F;&#x2F; npm run artisan -- test -x=1 --type 2 a b\n&#x2F;&#x2F; npm run artisan -- test -x 1 --type 2 a b\n</code></pre><p><img src=\"//static.cnodejs.org/Fo_qyNoHurw_Z_IYQrWX9v5NvdTy\" alt=\"3.png\"></p>\n<h4>Call the artisan command inside the project</h4>\n<p><code>egg-artisan</code> provides <code>app.runArtisan(artisanCommand, [argvs])</code> for running some commands inside the project. <code>app.runArtisan(artisanName, [argvs])</code> accepts two parameters:</p>\n<ul>\n<li>artisanCommand: Relative path or absolute path in the app/artisan directory, such as <code>test</code>, <code>{app_root}/app/artisan/test</code>; You can also append parameters, such as <code>test -x=1 --type=2</code>, <code>{app_root}/app/artisan/test -x=1 --type=2</code>.</li>\n<li>argvs: command argvs, will be parsed and appended to <code>artisanCommand</code>. support object, array, such as <code>[ 'a', 'b' ]</code>, <code>{ '--a': 1, '--b': 2 }</code>, <code>{ a: true, '--b': 2 }</code>.</li>\n</ul>\n<p>Example:</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; {app_root}&#x2F;app&#x2F;controller&#x2F;home.js \n&#x27;use strict&#x27;;\n\nconst BaseController = require(&#x27;.&#x2F;base&#x27;);\n\nclass HomeController extends BaseController {\n  async index() {\n    await this.app.runArtisan(&#x27;test&#x27;, { &#x27;-a&#x27;: 1 })\n}\n\nmodule.exports = HomeController;\n</code></pre><p>more usage, reference <code>npm run artisan</code>:</p>\n<pre class=\"prettyprint language-js\"><code>npm run artisan -- test\napp.runArtisan(&#x27;test&#x27;)\n\nnpm run artisan -- test -a=1\napp.runArtisan(&#x27;test -a=1&#x27;)\napp.runArtisan(&#x27;test&#x27;, { &#x27;-a&#x27;: 1 })\n\nnpm run artisan -- test a b\napp.runArtisan(&#x27;test a b&#x27;)\napp.runArtisan(&#x27;test&#x27;, [ &#x27;a&#x27;, &#x27;b&#x27; ])\n\nnpm run artisan -- test -a=1 --bb=2\napp.runArtisan(&#x27;test -a=1 --bb=2&#x27;)\napp.runArtisan(&#x27;test&#x27;, { &#x27;-a&#x27;: 1, &#x27;--bb&#x27;: 2 })\n\nnpm run artisan -- test -a=1 --bb=2 cc\napp.runArtisan(&#x27;test -a=1 --bb=2 cc&#x27;)\napp.runArtisan(&#x27;test -a=1&#x27;, { &#x27;--bb&#x27;: 2, cc: true })\napp.runArtisan(&#x27;test&#x27;, { &#x27;-a&#x27;: 1, &#x27;--bb&#x27;: 2, cc: true })\n\n</code></pre><h4>advanced usage</h4>\n<ul>\n<li>\n<p>Combined <code>egg-schedule</code></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; {app_root}&#x2F;app&#x2F;schedule&#x2F;xxx.js\nconst Subscription = require(&#x27;egg&#x27;).Subscription;\nclass ClusterTask extends Subscription {\n  static get schedule() {\n    return {\n      type: &#x27;custom&#x27;,\n    };\n  }\n  async subscribe(data) {\n    await this.ctx.app.runArtisan(&#x27;test&#x27;, { &#x27;-a&#x27;: 1 });\n  }\n}\n</code></pre></li>\n</ul>\n<h3>结语</h3>\n<p>如有问题或有优化的点，欢迎pr, star。</p>\n<blockquote>\n<p>github: <a href=\"https://github.com/zzzs/egg-artisan\">https://github.com/zzzs/egg-artisan</a></p>\n</blockquote>\n</div>",
            "title": "egg-artisan: 提供一个基于egg的命令行运行模式。",
            "last_reply_at": "2018-10-19T04:20:09.666Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 311,
            "create_at": "2018-10-18T17:30:29.245Z",
            "author": {
                "loginname": "zzzs",
                "avatar_url": "https://avatars1.githubusercontent.com/u/11943801?v=4&s=120"
            }
        },
        {
            "id": "5ab9d855320bb09d69e23246",
            "author_id": "55c56e8a39273b9219336288",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>源码: <a href=\"https://github.com/timqian/gql-generator\">https://github.com/timqian/gql-generator</a></p>\n<p>在为 graphql server 写 api test 的时候，每个 test 都需要手写 query。容易出现小错误，而且当 schema 有改变的时候，要去更新它们十分不便。</p>\n<p>事实上，query 长什么样应该可以从 schema 里生成出来。</p>\n<p>于是有了这个小工具</p>\n<pre class=\"prettyprint language-graphql\"><code># Sample schema\ntype Query {\n    user(id: Int!): User!\n}\n\ntype User {\n    id: Int!\n    username: String!\n    email: String!\n    createdAt: String!\n}\n</code></pre><pre class=\"prettyprint language-gql\"><code># Sample query generated\nquery user($id: Int!) {\n    user(id: $id){\n        id\n        username\n        email\n        createdAt\n    }\n}\n</code></pre><p>具体介绍及使用方法见 github: <a href=\"https://github.com/timqian/gql-generator\">https://github.com/timqian/gql-generator</a></p>\n</div>",
            "title": "从 Graphql Schema 生成 Graphql query",
            "last_reply_at": "2018-10-19T04:05:10.413Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 748,
            "create_at": "2018-03-27T05:36:21.145Z",
            "author": {
                "loginname": "timqian",
                "avatar_url": "https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"
            }
        },
        {
            "id": "5b752e507271129a2f32aa38",
            "author_id": "59a6b1f66c90694908d81520",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我们的网站采用内嵌微信二维码扫码登录，\n偶然会出现扫码无响应的情况，手机上已经确认，但是二维码下面没有确认字样，\n打开chrome控制台，有如下信息：\n<img src=\"//static.cnodejs.org/FkchxDHu_CQnbe6Grqmi4pbdyRD0\" alt=\"image.png\">\n请问是什么原因？有大神指点下吗</p>\n</div>",
            "title": "微信扫码登录，扫码后无响应，chrome控制台报错：err_empty_response",
            "last_reply_at": "2018-10-19T03:37:37.971Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 462,
            "create_at": "2018-08-16T07:57:04.492Z",
            "author": {
                "loginname": "dolphinfine",
                "avatar_url": "https://avatars1.githubusercontent.com/u/27426130?v=4&s=120"
            }
        },
        {
            "id": "5bc88cb8ede204052db80636",
            "author_id": "59f007c928137001719a81e9",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>各位大佬请问下 这种模块是什么意思?没看懂\nconst fs = require(‘mz/fs’);</p>\n<p>const pump = require(‘mz-modules/pump’);</p>\n</div>",
            "title": "mz 模块是什么意思？？require('mz/fs');",
            "last_reply_at": "2018-10-19T03:25:43.871Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 554,
            "create_at": "2018-10-18T13:38:00.187Z",
            "author": {
                "loginname": "1016716110",
                "avatar_url": "https://avatars2.githubusercontent.com/u/30174358?v=4&s=120"
            }
        },
        {
            "id": "5b8de66137b3005a0b0e6b3f",
            "author_id": "5b8de41bbf116a8c0e42579f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>",
            "title": "Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢",
            "last_reply_at": "2018-10-19T03:01:46.362Z",
            "good": false,
            "top": false,
            "reply_count": 44,
            "visit_count": 4042,
            "create_at": "2018-09-04T01:56:49.179Z",
            "author": {
                "loginname": "zlyuanteng",
                "avatar_url": "https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"
            }
        },
        {
            "id": "5bc8391b15e4fd1923f49058",
            "author_id": "564582ec5e7412b625b8bf16",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>现在的问题是，多个项目共享一个node_modules 文件夹，但是项目的路径不一样，如何实现多项目公用一个node_modules</p>\n</div>",
            "title": "如何自定义node 项目的node_modules 路径",
            "last_reply_at": "2018-10-19T02:18:24.270Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 630,
            "create_at": "2018-10-18T07:41:15.577Z",
            "author": {
                "loginname": "RajanZhan",
                "avatar_url": "https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"
            }
        },
        {
            "id": "5a6728719288dc81532880e0",
            "author_id": "59588bdf545d7a7b5b0b389f",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>用的是nodemon的热更新开发，怎么加eslint语法检测呢？\n就是每次保存代码eslint检测语法，没有问题nodemon继续运行。</p>\n</div>",
            "title": "node写代码如何加eslint语法检测",
            "last_reply_at": "2018-10-19T02:12:17.541Z",
            "good": false,
            "top": false,
            "reply_count": 22,
            "visit_count": 2554,
            "create_at": "2018-01-23T12:20:01.079Z",
            "author": {
                "loginname": "mengdu",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"
            }
        },
        {
            "id": "5bc86c5237a6965f5905237a",
            "author_id": "5b74f778a210553a0cde2979",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>每次想要使用pubsub.js的时候都要在要使用的组件引入一遍，一是感觉好麻烦，二是感觉复用性不好，所以我按照自己个人之前在Vue中全局引入其他插件的方法，想到了，在Main.js文件中，“import Pubsub from ‘pubsub-js’”,然后使用Vue.use来达到全局使用的目的，但是发现不管用，求大神踩下坑，指点下，谢谢。</p>\n</div>",
            "title": "怎么在Vue中全局引入pubsub.js？",
            "last_reply_at": "2018-10-19T02:08:46.758Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 648,
            "create_at": "2018-10-18T11:19:46.291Z",
            "author": {
                "loginname": "zhuhaifeng1251pm",
                "avatar_url": "https://avatars1.githubusercontent.com/u/41354007?v=4&s=120"
            }
        },
        {
            "id": "5a72c66ace45d440451465c3",
            "author_id": "58400cd63aa1310a5786878f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>总共录了18集，课程主要针对 nodejs 初学者，查看下面网址：</p>\n<p><a href=\"https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian\">https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian</a></p>\n<p>录制视频不易，如果对你有帮助，请多多支持。</p>\n<p>下一套课程计划：Nodejs + express</p>\n</div>",
            "title": "18集 Node.js 视频入门教程 - 全部免费观看",
            "last_reply_at": "2018-10-19T02:02:43.594Z",
            "good": false,
            "top": false,
            "reply_count": 35,
            "visit_count": 16690,
            "create_at": "2018-02-01T07:48:58.823Z",
            "author": {
                "loginname": "yinsigan",
                "avatar_url": "https://avatars2.githubusercontent.com/u/740643?v=4&s=120"
            }
        },
        {
            "id": "5bc712ae37a6965f59052301",
            "author_id": "599e2723ebaa046923a826f0",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>因为项目可能需要进行保密，让客户无法找到源码，需要打包，看到egg的issue有了解到node-packer。\n接着看到官方的例子，是对egg-bin.js 进行nodec，为什么呢？我自己试了egg-script，结果出来的执行文件还是需要app那些文件夹…求助高手。\n看到node-packer的issue里面也有相关的<a href=\"https://github.com/pmq20/node-packer/issues/118\">https://github.com/pmq20/node-packer/issues/118</a></p>\n</div>",
            "title": "使用node-packer要怎么打包egg应用来启动和部署？",
            "last_reply_at": "2018-10-19T02:02:01.068Z",
            "good": false,
            "top": false,
            "reply_count": 10,
            "visit_count": 746,
            "create_at": "2018-10-17T10:45:02.898Z",
            "author": {
                "loginname": "HobaiRiku",
                "avatar_url": "https://avatars2.githubusercontent.com/u/26238803?v=4&s=120"
            }
        },
        {
            "id": "5bc939889545eaf107b9cc8a",
            "author_id": "5b816810a210553a0cde2c12",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>2018最新node.js Web全栈工程师项目实战开发学习0基础入门到精通视频教程，共39章节。\n本套<a href=\"http://www.sucaihuo.com/video/224-0-0\">Node.js视频教程</a>为2018年根据目前市场需求倾情录制，最易懂、最实用的node.js高清视频教程+课件+源码,资料齐全，教程讲解细致，助有需要的朋友很快上手。\n<img src=\"//static.cnodejs.org/FoIt4gn_1gAtJIKyacr6pdd6r8j1\" alt=\"big.jpg\"></p>\n<p><strong>课程目录：</strong>\n01 NodeJs 简介 安装 开发工具配置\n02 Nodejs Http模块 Url模块 supervisor工具\n03 CommonJs 和 Nodejs 模块、自定义模块\n04 NPM 命令使用  第三方模块和 package.json 、cnpm安装\n05 Nodejs中的fs模块(上)\n06 Nodejs中的fs demo(中)\n07 Nodejs中的fs 流(下)\n08 利用HTTP模块 URl模块 Path模块 Fs模块创建一个静态WEB服务器 读取文件获取响应类型（下）\n09 利用HTTP模块 URl模块 Path模块 Fs模块创建一个静态WEB服务器（上）\n10 Nodejs的非阻塞IO、异步以及 事件驱动EventEmitter解决异步\n11 Nodejs WEB服务器 静态文件托管、 GET POST路由 EJS模板引擎（上）\n12 Nodejs WEB服务器 静态文件托管、 GET POST路由 EJS模板引擎（下）\n13 Nodejs 路由封装 模块化方式封装（上）\n14 Nodejs封装一个类似express框架的路由（中）\n15 Nodejs封装一个类似express框架的路由（下）\n16 MongoDb 数据库介绍、安装、使用\n17 MongoDB 数据库创建删除、表（集合）创建删除、数据增删改查\n18 MongoDB 数据库的删除  表的删除  数据的修改、删除\n19 MongoDB 索引 explain 分析查询速度\n20 NodeJs操作MongoDb数据库 数据的增加 修改 删除\n21 NodeJs操作MongoDb数据库 查询数据ejs显示列表\n22 Express 框架介绍 安装 路由 动态路由 get传值\n23 Express  ejs使用 静态文件托管\n24 Express中间件 body-parser中间件\n25 Express中间件 cookie的基本使用\n26  Express中间件 cookie 多个二级域名共享cookie、cookie中的其他参数\n27 Express cookie的加密\n28 Express cookie中实现简单的记录浏览过的历史记录信息\n29 Express中间件 express-session常见参数配置使用\n30 Express-session 多服务器负载均衡 session保存到数据库\n31 Express商品管理系统介绍、框架搭建、ejs 、express.static静态页面搭建\n32 Express商品管理系统查询mongodb数据库登录功能\n33 Express登录功能、 中间件权限判断、退出登录功\n34 Express 密码加密存储 数据库商品列表显示\n35 Express商品管理系统 DB数据库的封装\n36 Express商品管理系统 图片上传 和增加商品数据 修改商品数据\n37 Express商品管理系统 修改商品数据 删除商品数据\n38 Express 路由模块化\n39 Express商品管理系统模块化改造\n下载地址：<a href=\"http://www.sucaihuo.com/video/433.html\">http://www.sucaihuo.com/video/433.html</a></p>\n</div>",
            "title": "2018最新Node.js高清视频教程+课件+源码",
            "last_reply_at": "2018-10-19T01:59:50.992Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 179,
            "create_at": "2018-10-19T01:55:20.154Z",
            "author": {
                "loginname": "abochi",
                "avatar_url": "https://avatars2.githubusercontent.com/u/42697622?v=4&s=120"
            }
        },
        {
            "id": "5bc42ad4ede204052db80549",
            "author_id": "5a7a5d505321b5396004ec1e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>BUG 修复：</h2>\n<p>优化了上传逻辑\n完善了service</p>\n<p><img src=\"https://static.oschina.net/uploads/img/201810/11175918_0WHp.jpg\" alt></p>\n<p>Demo:  <a href=\"https://demo.neditor.notadd.com/\">https://demo.neditor.notadd.com/</a></p>\n<h2>下载地址</h2>\n<p>Neditor 码云： <a href=\"http://gitee.com/notadd/neditor\">http://gitee.com/notadd/neditor</a>\nNeditor github 地址：<a href=\"http://github.com/notadd/neditor\">http://github.com/notadd/neditor</a></p>\n</div>",
            "title": "Web 富文本编辑器 Neditor 2.1.6 发布，优化上传逻辑",
            "last_reply_at": "2018-10-19T01:51:31.459Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 537,
            "create_at": "2018-10-15T05:51:16.301Z",
            "author": {
                "loginname": "zuohuadong",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"
            }
        },
        {
            "id": "5b5e78f5673571454c633cea",
            "author_id": "5b56866ae740336c7bedb345",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>",
            "title": "Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程",
            "last_reply_at": "2018-10-19T01:50:44.742Z",
            "good": false,
            "top": false,
            "reply_count": 50,
            "visit_count": 6741,
            "create_at": "2018-07-30T02:33:25.113Z",
            "author": {
                "loginname": "songsunli",
                "avatar_url": "https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"
            }
        }
    ]
}